{"pages":[],"posts":[{"title":"Noverish의 기술 블로그 시작합니다!","text":"Noverish의 기술 블로그 시작합니다!","link":"/init/"},{"title":"ESLint + Typescript","text":"Typescript 프로젝트에서 airbnb 스타일로 eslint를 적용해 보자! 목차1. ESLint 설치2. Typescript용 airbnb 스타일 설치하기3. Typescript 절대 경로 Import4. TL; DR 1. ESLint 설치npm install -D eslint 명령어로 간단히 eslint를 설치할 수 있습니다. npx eslint --init 명령어로 .eslintrc.json 을 생성할 수 있습니다. 만약 React 프로젝트일 경우 그에 맞게 선택해 주시면 됩니다. 제가 선택한 옵션은 다음과 같습니다. 12345678910111213141516171819202122232425262728293031323334353637383940$ npx eslint --init? How would you like to use ESLint? To check syntax only To check syntax and find problems ❯ To check syntax, find problems, and enforce code style? What type of modules does your project use? JavaScript modules (import/export) CommonJS (require/exports) ❯ None of these? Which framework does your project use? React Vue.js ❯ None of these? Does your project use TypeScript? (y/N) y? Where does your code run? (Press &lt;space&gt; to select, &lt;a&gt; to toggle all, &lt;i&gt; to invert selection)❯◯ Browser ◉ Node? How would you like to define a style for your project? ❯ Use a popular style guide Answer questions about your style Inspect your JavaScript file(s)? Which style guide do you want to follow?❯ Airbnb: https://github.com/airbnb/javascript Standard: https://github.com/standard/standard Google: https://github.com/google/eslint-config-google? What format do you want your config file to be in? JavaScript YAML ❯ JSON@typescript-eslint/eslint-plugin@latest eslint-config-airbnb-base@latest eslint@^5.16.0 || ^6.8.0 eslint-plugin-import@^2.20.1 @typescript-eslint/parser@latest? Would you like to install them now with npm? (Y/n) Y 그러면 아래와 같은 .eslintrc.json 파일이 생성됩니다. 123456789101112131415161718192021{ \"env\": { \"es6\": true, \"node\": true }, \"extends\": [ \"airbnb-base\" ], \"globals\": { \"Atomics\": \"readonly\", \"SharedArrayBuffer\": \"readonly\" }, \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": { \"ecmaVersion\": 2018 }, \"plugins\": [ \"@typescript-eslint\" ], \"rules\": {}} 다음과 같은 명령어로 eslint를 실행할 수 있습니다. 123$ npx eslint 'src/**/*.ts' # 단순히 문법 검사만 함$ npx eslint 'src/**/*.{ts,tsx}' # tsx 파일도 검사함$ npx eslint 'src/**/*.ts' --fix # 고칠수 있는 부분은 고치고 고칠 수 없는 부분은 출력함 2. Typescript용 airbnb 스타일 설치하기실제로 eslint 명령어를 수행하면 Type을 import한 부분에 대해서는 사용하지 않았다는 아래와 같은 에러를 출력합니다. 123import { SomeType } from 'some-package';const something: SomeType | null = null; 1error 'SomeType' is defined but never used no-unused-vars 이러한 에러가 발생하는 이유는 .eslintrc.json를 생성할 때 설치된 airbnb 스타일이 Typescript용이 아니기 때문입니다. 따라서 Typescript용 airbnb 스타일을 설치 해야 합니다. 2.1. React 프로젝트가 아닌 경우1$ npm install -D eslint-config-airbnb-typescript 위와 같이 설치 한 다음 .eslintrc.json을 다음과 같이 수정합니다. 1234567 \"extends\": [- \"airbnb-base\"+ \"airbnb-typescript/base\" ], \"parserOptions\": {+ \"project\": \"./tsconfig.json\" }, 2.2. React 프로젝트인 경우12345$ npm install eslint-config-airbnb-typescript \\ eslint-plugin-jsx-a11y \\ eslint-plugin-react \\ eslint-plugin-react-hooks@^1.7.0 \\ --save-dev 위와 같이 설치 한 다음 .eslintrc.json을 다음과 같이 수정합니다. 1234567 \"extends\": [- \"airbnb-base\"+ \"airbnb-typescript\" ], \"parserOptions\": {+ \"project\": \"./tsconfig.json\" }, 이제 다시 eslint 명령어를 수행하면 아까와 같은 에러가 더이상 발생하지 않는 것을 알 수 있습니다. 3. Typescript 절대 경로 Import일반적으로 Typescript 프로젝트에서는 import * as ssl from '../../../services/ssl' 과 같은 import 경로를 피하기 위해 절대 경로 import를 많이 사용합니다. 아래와 같이 tsconfig.json 을 수정하면 import * as ssl from '@src/services/ssl' 처럼 절대 경로로 import 할 수 있습니다. 123456{ \"compilerOptions\": { \"baseUrl\": \".\", \"paths\": {\"@src/*\" : [\"./src/*\"]} }} 하지만 eslint 에서는 이 경로를 인식하지 못해서 아래와 같은 에러가 발생합니다. 1error Unable to resolve path to module '@src/services/ssl' import/no-unresolved 이러한 문제를 해결 하기 위해서는 eslint-import-resolver-typescript라는 패키지를 설치해 주셔야 합니다. 1$ npm i -D eslint-import-resolver-typescript 위와 같이 설치 한 다음 .eslintrc.json에 다음을 추가합니다. 1234567{ \"settings\": { \"import/resolver\": { \"typescript\": {} } }} 4. TL; DR4.1. React 프로젝트가 아닌 경우Package 설치1234567$ npm install eslint \\ eslint-plugin-import \\ @typescript-eslint/eslint-plugin \\ @typescript-eslint/parser \\ eslint-config-airbnb-typescript \\ eslint-import-resolver-typescript \\ --save-dev Project Root에 .eslintrc.json 생성1234567891011121314151617181920212223242526272829303132{ \"env\": { \"es6\": true, \"node\": true }, \"extends\": [ \"airbnb-typescript/base\" ], \"globals\": { \"Atomics\": \"readonly\", \"SharedArrayBuffer\": \"readonly\" }, \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": { \"ecmaVersion\": 2018, \"project\": \"./tsconfig.json\" }, \"plugins\": [ \"@typescript-eslint\" ], \"rules\": { \"radix\": \"off\", \"no-console\": \"off\", \"@typescript-eslint/no-use-before-define\": \"off\", \"@typescript-eslint/no-unused-vars\": [\"error\", { \"args\": \"none\" }] }, \"settings\": { \"import/resolver\": { \"typescript\": {} } }} 4.2. React 프로젝트인 경우Package 설치12345678910$ npm install eslint \\ eslint-plugin-import \\ eslint-plugin-jsx-a11y \\ eslint-plugin-react \\ eslint-plugin-react-hooks@^1.7.0 \\ @typescript-eslint/eslint-plugin \\ @typescript-eslint/parser \\ eslint-config-airbnb-typescript \\ eslint-import-resolver-typescript \\ --save-dev Project Root에 .eslintrc.json 생성1234567891011121314151617181920212223242526272829303132{ \"env\": { \"browser\": true, \"es6\": true }, \"extends\": [ \"airbnb-typescript\" ], \"globals\": { \"Atomics\": \"readonly\", \"SharedArrayBuffer\": \"readonly\" }, \"parser\": \"@typescript-eslint/parser\", \"parserOptions\": { \"ecmaFeatures\": { \"jsx\": true }, \"ecmaVersion\": 2018, \"project\": \"./tsconfig.json\" }, \"plugins\": [ \"react\", \"@typescript-eslint\" ], \"rules\": { }, \"settings\": { \"import/resolver\": { \"typescript\": {} } }}","link":"/Node/eslint/"},{"title":"Android에 푸쉬 알림 보내기 - 클라이언트편","text":"Node.js와 Google Firebase를 사용하여 Android에 푸쉬 알림 보내는 방법을 알아보겠습니다 (클라이언트 편) 목차1. 안드로이드 프로젝트 생성 2. Firebase 프로젝트 생성 3. Firebase 프로젝트에 안드로에드 앱 추가 4. 안드로이드 프로젝트에 코드 작성 5. 기기 토큰 값 확인 1. 안드로이드 프로젝트 생성 안드로이드 프로젝트를 만드는 법은 굳이 설명하지 않도록 하겠습니다.여기서 저 Package Name은 밑에서 쓰이므로 기억해두세요. 2. Firebase 프로젝트 생성 먼저 Firebase Console로 들어갑니다. 그런 다음 프로젝트 추가 버튼을 누릅니다. 프로젝트 이름을 입력하여 프로젝트를 만듭니다.저는 간단하게 FCM-Example로 했습니다. 3. Firebase 프로젝트에 안드로에드 앱 추가 프로젝트가 생성되고 난 뒤 나타난 화면에서 안드로이드 버튼을 눌러 앱을 추가합니다. 안드로이드 프로젝트를 생성할 때 나왔던 패키지 이름을 입력합니다.앱 닉네임은 적당히 적고 앱 등록을 누릅니다. 그럼 이렇게 구성파일을 다운로드 하라고 하는데 google-services.json 파일을 다운로드 한 다음 아래와 같이 app 폴더 안에 넣어줍니다. 위의 지시사항 대로 Firebase SDK를 gradle을 통해 추가 합니다. 앱을 실행하여 제대로 설정이 되었는지 확인합니다. 앱이 실행이 되면 자동으로 아래와 같이 바뀝니다. 만약 앱을 실행 시켜도 콘솔로 이동하는 버튼이 활성화 되지 않는 다면 몇 번 더 앱을 재실행 시켜주시면 됩니다. 위와 같이 하면 다음과 같이 앱이 제대로 추가 되어 있는 것을 볼 수 있습니다. 4. 안드로이드 프로젝트에 코드 작성1implementation 'com.google.firebase:firebase-messaging:17.3.3' 위의 코드를 통해 fireabse messaging 라이브러리를 설치 합니다 2019-01-02 기준 라이브러리 버전은 17.3.1 입니다. 현재 버전을 알고 싶으면 여기서 확인해 주세요 MyFirebaseInstanceIDService.kt를 만들고 아래의 코드를 입력합니다. MyFirebaseMessagingService.kt123456789101112131415161718192021package kim.hyunsub.fcm_exampleimport com.google.firebase.messaging.FirebaseMessagingServiceimport com.google.firebase.messaging.RemoteMessageclass MyFirebaseMessagingService : FirebaseMessagingService() { override fun onNewToken(token: String?) { super.onNewToken(token) println(\"Refreshed token: \" + token!!) } override fun onMessageReceived(remoteMessage: RemoteMessage?) { super.onMessageReceived(remoteMessage) remoteMessage?.notification?.let { noti -&gt; println(\"title : ${noti.title}\") println(\"body : ${noti.body}\") } }} onNewToken(token: String?) 기기의 Firebase Token 값이 변하면(생성되면) 이 메서드가 호출이 됩니다. 이 함수에서 본인의 서버로 token 값을 보내는 코드를 넣어서 이 토큰 값을 가지고 앱에 푸쉬 알림을 보내시면 됩니다. onMessageReceived(remoteMessage: RemoteMessage?) Firebase 서버에서 푸쉬알림을 받으면 이 메서드가 호출이 됩니다. 이 메서드에서 사용자에게 알림을 보내시면 됩니다. AndroidManifest.xmlAndroidManifest.xml의 application태그 안에 아래를 입력합니다. 123456&lt;service android:name=\".MyFirebaseMessagingService\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.google.firebase.MESSAGING_EVENT\"/&gt; &lt;/intent-filter&gt;&lt;/service&gt; 위의 코드를 전부 작성하고 앱을 실행하면 이렇게 창에 기기 token 값이 생성되서 나옵니다.기기에 따라 몇 초에서 몇 분정도는 걸릴 수 있습니다. 5. 기기 토큰 값 확인MainActivity.kt12345678910FirebaseInstanceId.getInstance().instanceId .addOnCompleteListener(OnCompleteListener { task -&gt; if (!task.isSuccessful) { print(\"get token failed ${task.exception}\") return@OnCompleteListener } val token = task.result!!.token print(\"get token : $token\") }) 토큰 값이 생성된 이후에 다시 기기의 token 값을 알아내려면 위의 코드를 통해 알아내시면 됩니다.","link":"/Android/Firebase-Push-Notification-1/"},{"title":"Android에 푸쉬 알림 보내기 - 서버편","text":"Node.js와 Google Firebase를 사용하여 Android에 푸쉬 알림 보내는 방법을 알아보겠습니다 (서버 편) 1. Firebase 콘솔에서 비공개 키 받기 프로젝트 콘솔페이지에서 설정 - 프로젝트 설정으로 들어갑니다. 서비스 계정 탭으로 이동합니다. 새 비공개 키 생성을 클릭하여 json 파일을 다운로드 받습니다. 2. Node.js 프로젝트에 Firebase 추가1$ npm install firebase-admin --save 위의 명령어를 통해 npm 프로젝트에 firebase 패키지를 설치 합니다. 12345678var admin = require('firebase-admin');var serviceAccount = require('path/to/serviceAccountKey.json');admin.initializeApp({ credential: admin.credential.cert(serviceAccount), databaseURL: 'https://&lt;DATABASE_NAME&gt;.firebaseio.com'}); 위의 코드를 통해 admin을 초기화 합니다. 3. 개별 기기로 메시지 전송123456789101112131415161718192021// Registration Token 은 안드로이드 앱에서 나온 Token 입니다.var registrationToken = 'YOUR_REGISTRATION_TOKEN';// See documentation on defining a message payload.var message = { data: { score: '850', time: '2:45' }, token: registrationToken};// 메시지를 보냅니다.admin.messaging().send(message) .then((response) =&gt; { // Response is a message ID string. console.log('Successfully sent message:', response); }) .catch((error) =&gt; { console.log('Error sending message:', error); }); 성공적으로 완료되면 send() 메소드는 메시지 ID 문자열을 projects/{project_id}/messages/{message_id} 형식으로 반환합니다. 그렇지 않은 경우 오류가 표시됩니다. 설명 및 해결 단계가 포함된 전체 오류 코드 목록은 Admin FCM API 오류를 참조하세요. 자세한 문서","link":"/Android/Firebase-Push-Notification-2/"},{"title":"AWS Cloud9 사용해보기","text":"클라우드 IDE인 Cloud9을 통해 언제 어디서나 웹 브라우저를 통해 내 환경에서 개발하는 방법을 알아보겠습니다. 목차1. 환경 만들기2. 보안그룹 설정3. Apache2 삭제4. 기본적으로 설치되어 있는 것들5. 간단한 노드 서버 만들어 보기6. 단축키7. 파일 업로드 &amp; 다운로드 1. 환경 만들기 1) Cloud9 콘솔에 들어가서 Create environment를 클릭합니다. 2) Name에 WorkSpace를 적고 Next Step을 클릭합니다. 3) 각종 설정을 하고 다음으로 넘어갑니다. Environment Type : 새로운 EC2를 만들 것인지 아니면 기존에 있던 서버에 Cloud9환경을 추가할지 선택합니다. Cloud9은 무슨 새로운 패키지를 설치하는 것이 아니라 .c9 폴더에 Cloud9 환경 정보를 저장해 놓고 Cloud9에서 서버에 접속해 이 폴더를 사용하는 것 뿐입니다. 환경을 삭제하려면 단순히 .c9 폴더를 삭제하시면 됩니다. 저는 새로운 EC2를 만드려고 해서 위와 같은 옵션을 선택했습니다. Instance Type : 새로운 EC2의 인스턴스 타입을 선택합니다. 일반적으로 24시간 돌리는 서버와는 다르게 쓰는 만큼만 요금이 나가므로 비교적 비싼 타입을 선택하셔도 됩니다. Platform : 설치할 OS를 선택합니다. 저는 Ubuntu를 선택했습니다. Cost-saving setting : Cloud9 웹 IDE 페이지를 종료한 후 몇 시간 후에 자동으로 EC2를 중지할 지 선택합니다. 최소 단위가 30분이고 저는 이 옵션을 선택했습니다. 4) 앞서 설정한 옵션들을 검토하는 화면입니다. 별 문제 없으면 Create environment를 클릭해서 환경을 만듭니다. 2. 보안그룹 설정 보안 그룹 설정에 본인이 쓰실 포트를 추가해 주시면 됩니다. 싸지방은 포트가 80번과 443번밖에 안 뚫려있기 때문에 저는 80번과 443번을 추가했습니다. 3. Apache2 삭제 Cloud9을 켜신후 서버의 아이피 주소로 들어가 보시면 위와 같이 Apache2 페이지를 보실 수 있습니다. 자동으로 Apache2 웹 서버가 구동되어 있기 때문입니다. 저와 같이 Apache2를 쓰지 않으시는 분은 Apache2를 삭제 하셔서 80번 포트를 아무도 안 쓰게 해주셔야 합니다. 아래의 명령어를 입력해서 Apache2를 삭제합니다. 12$ sudo service apache2 stop$ sudo apt-get purge apache2 apache2-utils 다른 블로그 같은 곳에서 sudo apt autoremove를 하라는 곳도 있을 텐데 제 경험상 이 걸 하면 기본적으로 설치되어 있는 node가 고장났던 경험이 있습니다. 알아서 해보시길 바랍니다. 위의 명령어 만으로 Apache2가 삭제 되지만 완전히 모든 파일이 삭제되지는 않습니다. 만약 모든 파일을 삭제하시길 원하시면 아래와 같은 명령어로 삭제해 주시길 바랍니다. 123ubuntu:~/environment $ whereis apache2apache2: /usr/sbin/apache2 /usr/lib/apache2 /etc/apache2 /usr/share/apache2 /usr/share/man/man8/apache2.8.gzubuntu:~/environment $ sudo rm -rf /etc/apache2 4. 기본적으로 설치되어 있는 것들아래는 기본적으로 설치되어 있는 패키지들 목록입니다. 제가 모르는 것이 더 있을 수 있습니다. 5. 간단한 노드 서버 만들어 보기간단한 노드 서버를 만들어 보도록하겠습니다. 이 과정이 필요 없으신 분들은 건너 뛰셔도 됩니다. 기본적으로 환경 변수 PORT가 8080으로 설정되어 있어 환경 변수를 이용하는 코드를 쓰시는 분들은 주의해주시길 바랍니다. (아래의 명령어 참조) 12ubuntu:~/environment/node $ echo $PORT8080 1) index.js 파일을 만들고 아래와 같이 작성합니다. 1234567891011const http = require('http');const server = http.createServer(function (req, res) { console.log('hello world'); res.statusCode = 200; res.end('hello world\\n');})server.listen(80, function() { console.log('Server Start!!'); }); 2) 아래의 명령어를 통해 서버를 구동하고 서버의 아이피 주소를 이용하여 접속합니다. 1$ sudo node index.js 6. 단축키Ctrl + S 저장 Alt + W 에디터 탭 닫기 Alt + N 새 파일 Alt + T 새 터미널 주의사항 : Ctrl + W 는 에디터 창 닫기가 아니라 웹페이지 탭 닫기라서 Cloud9이 꺼져버립니다. 위의 모든 단축키는 설정에서 수정하실 수 있습니다. 7. 파일 업로드 &amp; 다운로드1) 파일 업로드 Cloud9 왼쪽에 뜨는 폴더 Hierarchy에서 원하시는 디렉토리에 드래그 앤 드롭하시면 됩니다. 또는 메뉴의 File - Upload Local Files... 를 이용하시면 됩니다. 2) 파일 다운로드 Cloud9 왼쪽에 뜨는 폴더 Hierarchy에서 원하시는 파일을 마우스 오른쪽 클릭하시면 다운로드 됩니다.","link":"/Server/Cloud9/"},{"title":"AWS EC2로 나만의 Proxy 서버 만들기","text":"복잡한 서버 설정 없이 Proxy Server를 만드는 법을 알아봅시다. 우리는 세상 살면서 여러가지 이유로 해외 IP로 접속해야 하는 사이트가 존재합니다. 그게 무슨 사이트인지는 굳이 언급하지 않도록 하겠습니다 ㅎㅎ. 시중에 있는 무료 Proxy는 너무 속도가 느리고 그렇다고 유료 Proxy을 쓰자니 돈이 좀 아까운 느낍이 듭니다. 그래서 EC2로 Proxy Server를 만드는 법을 알려드리도록 하겠습니다. 1. 해외 Region에서 EC2 만들기이건 쉬우므로 건너 뛰도록 하겠습니다. 2. Mac에서 VPN 사용하기먼저 터미널을 켜주신 후 pem 파일이 있는 폴더로 가서 아래 명령어를 입력합니다. 아래 1.2.3.4를 본인 EC2의 IP로 바꿔주시길 바랍니다. 1$ ssh -i key_pair.pem -D 8080 -C -N user@1.2.3.4 위 명령어를 입력한 후 뭔가 실행된 상태로 되어 있으면 정상적으로 proxy tunnel을 생성한겁니다. 앞으로 접속하는 모든 사이트의 패킷들은 이 tunnel을 통과합니다. 2.1. 환경설정에서 Proxy 기능 켜고 끄기네트워크 환경설정에 들어갑니다. 고급 버튼을 누릅니다. 위 그림처럼 따라하시면 됩니다. 적용 버튼을 누르면 Proxy 기능이 켜집니다. Proxy를 끌 때는 저 설정에 들어가서 SOCKS 프록시를 체크해제 하시고 적용하시면 됩니다. 2.2. Command로 Proxy 기능 켜고 끄기근데 이렇게 일일이 환경설정 들어가서 Proxy를 키거나 끄면 너무 귀찮으니까 터미널에서 명령어로 처리하는 법을 알아봅시다. 먼저 본인이 지금 사용하고 있는 네트워크 인터페이스 이름을 알아내야 합니다. 그러기 위해서 아래 명령어를 입력해 그 리스트를 알아냅니다. 1$ networksetup -listnetworkserviceorder 저는 위와 같은 결과가 나왔습니다. 저는 제 맥북을 와이파이로 쓰고 있으므로 저 Wi-Fi가 제 와이파이 네트워크 인터페이스 이름입니다. 기타 다른 네트워크 어댑터를 쓰고 있다면 그에 맞는 인터페이스 이름을 찾으시면 됩니다. 이제 이 이름을 바탕으로 아래 명령어를 실행하시면 됩니다. VPN 켤 때 1$ networksetup -setsocksfirewallproxy \"Wi-Fi\" localhost 8080 VPN 끌 때 1$ networksetup -setsocksfirewallproxystate \"Wi-Fi\" off 4. Windows에서 VPN 사용하기제가 아는 선에서는 Mac과 달리 Windows에서 모든 패킷을 Proxy로 우회하는 방법이 없습니다. 만약 그런 방법이 있다면 제보해 주시길 바랍니다. 먼저 putty와 같이 ssh tunnel을 유지시키는 MyEnTunnel을 인터넷에서 다운받습니다. 위와 같이 아이피 주소, 유저 네임, 비밀번호를 입력하고, Enable Dynamic SOCKS를 체크하시고 저 포트를 8080로 바꿔줍니다. 그리고 Connect 버튼을 누르면 위와 같은 메시지가 뜰텐데 그냥 Yes 누르시면 됩니다. status 탭에 이렇게 로그가 뜰텐데 Connectino stable이라고 뜨면 성공적으로 ssh tunnel을 만든겁니다. 그리고 프로그램들을 가상 네트워크 인터페이스 상에 실행시켜줄 SocksCap64를 인터넷에서 다운받습니다. 여기서 예를 누르면 자동으로 웹 브로우저 목록을 불러옵니다. 뭐라는지 잘 모르겠지만 Accept를 눌러줍시다. 이와 같은 화면에서 좌상단의 Proxy 버튼을 누릅니다. 여기서 127.0.0.1과 8080을 입력한 다음에 저장하고 이 프로그램상에서 웹브라우저를 실행시키시면 됩니다.","link":"/Server/EC2-Your-Own-VPN/"},{"title":"EC2 Container Service(ECS) 사용하기 + AutoScaling","text":"EC2 Container Service(ECS) 사용하기 + AutoScaling 기본적인 Docker 사용법은 안다고 가정하겠습니다. (설치, 명령어 등) 현재 저는 접속하면 hello world를 띄워주는 서비스를 제공 하고 있습니다. 이 서비스는 AWS EC2와 nodejs를 사용하고 있습니다. ECS라는 서비스를 사용 하려고 합니다. 1. 도커 이미지 만들기Dockerfile1234567891011121314FROM ubuntu:16.04MAINTAINER Noverish Harold &lt;embrapers263@gmail.com&gt;WORKDIR /rootRUN apt-get updateRUN apt-get install -y nodejsRUN apt-get install -y gitRUN git clone https://github.com/Noverish/simple-nodejsCMD cd /root/simple-nodejs; git pull origin master; nodejs index.jsEXPOSE 80EXPOSE 443 위 처럼 자신이 만들고 싶은 도커 이미지의 Dockerfile을 만듭니다. Dockerfile은 만들 줄 아신다고 생각하겠습니다. 1$ docker build --tag main-image . Dockerfile이 있는 위치에서 위의 명령어를 통해 이름이 main-image인 도커 이미지를 만들었습니다. 2. ECS 설정하기 AWS ECS에 들어가서 시작하기를 누릅니다. 우리는 둘 다 할 것이므로 둘다 체크하고 넘어갑니다. 리포지토리 이름은 그냥 test라고 했습니다. 위의 명령어를 통해 리포지토리에 로그인 하고 이미지를 푸쉬하라는데 밑에 자세히 설명하도록 하겠습니다. 일단 AWS CLI를 설치해야 합니다. 맥 기준으로 1$ brew install awscli 명령어를 통해 AWS CLI를 설치합니다. 다른 OS는 알아서… 그다음에 설정을 해줘야 하는데 aws configure 명령어를 통해 IAM User의 Access ID와 Secret Key를 위 처럼 입력해주시면 됩니다. 이제 AWS CLI 설정은 끝났습니다. 아까 페이지의 명령어를 차례대로 따라하시면 됩니다. 1$ aws ecr get-login --no-include-email --region ap-northeast-2 이 명령어를 통해 로그인을 하면 위와 같이 엄청 긴 명령어가 나옵니다. 만약 위와 같이 에러 메세지가 나온다면 aws configure를 통해 설정 해준 유저에 권한이 없어서 생기는 문제입니다. AWS IAM에서 위의 권한을 유저에 할당하시면 됩니다. 아까의 명령어에서 반환된 결과를 복붙해서 실행합니다. 12$ docker tag main-image:latest 123456789123.dkr.ecr.ap-northeast-2.amazonaws.com/test:latest$ docker push 123456789123.dkr.ecr.ap-northeast-2.amazonaws.com/test:latest 위의 명령어는 예시 입니다. 본인의 명령어는 단계 2: Docker 이미지 빌드, 태그 지정 푸쉬 페이지에서 확인하시기 바랍니다. 우리가 만들어 놓은 도커 이미지 이름은 main-image이고 리포지토리 이름은 test입니다. 이에 주의하면서 위의 명령어를 입력하면 아래와 같이 업로드가 진행됩니다. 위의 명령어를 입력하면 위와 같이 우리가 만들어 놓은 이미지가 리포지토리에 푸쉬됩니다. 그 다음에 페이지의 다음 단계로 넘어갑니다. 작업 정의 이름을 test-task-definition으로 컨테이너 이름을 test-container으로 해줬습니다. 여기서 주의 해야 할 점은 위와 같이 호스트 포트를 꼭 0으로 해주어야 합니다! 0으로 해주지 않으면 뒤에서 할 AutoScaling을 할 때 Load Balancer의 포트 번호가 이미 사용 중이라고 해서 에러가 납니다. 여기서 0의 의미는 자동으로 할당한다는 의미 입니다. 서비스 이름을 test-service라고 지었습니다. 우리가 아까 호스트 포트를 0으로 설정해 놔서 강제로 Load Balancer를 사용 하는 것으로 되어 있습니다. 그리고 넘어갑니다. 자신이 원하는 설정 하시고 넘어갑니다. 인스턴스 시작 및 서비스 실행을 누릅니다 그러면 ELB, VPC, EC2등 다양한 것들을 설정합니다. 이 작업은 몇 분 정도 걸립니다. 작업이 끝나면 서비스 보기를 누릅니다. 위와 같이 나오면 성공입니다. 2. AutoScaling 설정하기 Auto Scaling을 누릅니다. 아직 아무 것도 없다고 뜹니다. 업데이트를 누릅니다. 그냥 넘어갑니다. 여기도 그냥 넘어갑니다. 저는 최소 작업 개수를 1개로 최대 작업 개수를 5개로 했습니다. 다르게 해도 상관 없습니다. 조정 정책 추가를 누릅니다. 정책 이름을 test-policy로 했습니다. 새 경보 생성을 누릅니다. 알람 이름을 test-alarm으로 했습니다. 위와 같이 한 다음에 저장을 누릅니다. 위에서 설정한 값의 의미는 1개의 컨테이너가 1분 이상 평균 CPU 사용량이 1퍼센트가 넘으면 경보가 울린다는 의미입니다. 조정 작업에서 1 추가로 합니다.이 의미는 경보가 울리면 작업을 1개 추가 한다는 의미 입니다. 그리고 다음 단계로 넘어갑니다. 서비스 업데이트를 누릅니다. 위와 같이 설정 작업이 끝날 때 까지 기다립니다. EC2 대쉬보드로 들어가서 로드밸런서의 DNS 주소를 찾습니다. 정상적으로 페이지가 나오는 걸 확인 할 수 있습니다. CloudWatch에 들어가면 위 사진과 같이 우리가 설정해 놓은 알림이 있는 것을 확인 할 수 있습니다. 이제 이 알림이 울리게 하기 위해 아까의 페이지에서 새로고침을 연타합니다! CPU 사용률을 늘려서 AutoScaling이 되는 것을 확인하기 위해서 입니다. (물론 설정해 놓은 사용률이 1%여서 굳이 안해도 경보가 울리긴 합니다.) 그러면 이렇게 경보가 생기는 것을 알 수 있습니다. 이제 ECS 대쉬보드로 넘어가면 AutoScaling이 된 것을 확인 할 수 있습니다.","link":"/Server/ECS-AutoScaling/"},{"title":"Elastic Stack - Elasticsearch 편","text":"정형 및 비정형 데이터를 시각화하고 분석하는데 용이한 Elastic Stack을 사용하는 법을 알아보겠습니다. 이 글은 Ubuntu 18.04.2 LTS 사용자를 대상으로 작성했습니다. 목차1. 설치하기1.1. Java 설치1.2. Elasticsearch 설치2. 실행하기3. 기본 사용법 1. 설치하기1.1. Java 설치Elasticsearch는 Java를 사용하므로 먼저 Java를 설치하셔야 합니다. 2019년 4월 16일부터 oracle-jdk를 다운로드 받으려면 무조건 License를 가지고 있어야 합니다. 따라서 OpenJDK를 설치하도록 하겠습니다 1234567# 1. OpenJDK를 설치합니다.$ sudo apt-get install -y openjdk-8-jre$ sudo apt-get install -y openjdk-8-jdk# 2. 설치가 잘 되었나 확인합니다.$ javac -version$ java -version 1.2. Elasticsearch 설치1) Elasticsearch를 다운로드 받습니다.1$ wget https://artifacts.elastic.co/downloads/elasticsearch/elasticsearch-6.5.0.deb 다른 버전의 설치 링크를 알고 싶으시다면 https://www.elastic.co/kr/downloads/past-releases를 방문하시면 됩니다. URL의 6.5.0 부분을 원하시는 버전으로 바꾸시면 그 버전이 다운로드 됩니다. 2) dpkg 명령어를 이용해 Elasticsearch를 설치합니다.1$ sudo dpkg -i elasticsearch-6.5.0.deb Elasticsearch는 다음과 같은 위치에 설치 됩니다. 내용 위치 설치 경로 /usr/share/elasticsearch 설정 파일 경로 /etc/elasticsearch 데이터 저장 경로 /var/lib/elasticsearch 로그 저장 경로 /var/log/elasticsearch 실행 파일 경로 /etc/init.d/elasticsearch 3) 서버가 시작 될 때 자동으로 시작되게 설정합니다.1$ sudo systemctl enable elasticsearch.service 4) option : Elasticsearch 삭제 방법 12$ sudo dpkg --purge elasticsearch$ find / -name elasticsearch -exec rm -r \"{}\" \\; 2. 실행하기12345# Elasticsearch 시작 명령어$ sudo service elasticsearch start# Elasticsearch 중지 명령어$ sudo service elasticsearch stop 아래의 명령어를 통해 정상적으로 실행이 되었는지 알 수 있습니다. Elasticsearch가 시작 되는 데 시간이 좀 걸리므로 1분 정도 지나서 시도해 주시길 바랍니다. 1$ curl http://localhost:9200 3. 데이터 넣기Elasticsearch에 대한 사용법은 다른 포스트에서 다루기로 하고 우리는 일단 ELK 스택을 실습해 보는 것을 목표로 하므로 일단 데이터를 넣어보는 것만 하겠습니다. 1) index 만들기1$ curl -XPUT http://localhost:9200/records?pretty 2) mapping 넣기1$ curl -XPUT http://localhost:9200/records/_mapping/_doc?pretty -d @mapping.txt -H \"Content-Type:application/json\" mapping.txt 3) document 넣기1$ curl -XPOST http://localhost:9200/records/_doc/_bulk?pretty --data-binary @bulk.txt -H \"Content-Type:application/x-ndjson\" bulk.txt 이로써 우리는 Elasticsearch를 구동하고 거기에 1000개의 상품 판매 목록 데이터를 집어 넣었습니다. 그러면 다음 포스트에서 Kibana로 이 데이터를 시각화 하는 방법에 대해 알아보도록 하겠습니다.","link":"/Server/ELK-1/"},{"title":"Server-Sent Event with Nodejs","text":"Nodejs과 Nginx에서 Sever-Sent Event를 사용하는 법 (with Typescript) 목차1. 시작2. Cookie 전송3. 각 이벤트마다 ID 부여4. 각 이벤트마다 타입 부여5. Client에서 연결 종료6. Server에서 연결 종료7. Nginx를 통해 통신 (proxy_pass를 사용하는 경우) 1. 시작1.1. ssestream 설치1$ npm install ssestream 1.2. Server-Side여기서 10번째 줄에 data에는 string을 넣어도 되고 object를 넣어도 된다. ssestream 내부에서 object를 JSON.stringify 함수를 통해 string으로 바꿔준다. index.ts 1234567891011121314151617import * as express from 'express';import * as SSEStream from 'ssestream';import sse from './sse';const app = express();function handleSSEStream(stream: SSEStream) { setInterval(() =&gt; { stream.write({ data: Date.now().toString(), }); }, 100);}app.use('/sse', sse(handleSSEStream));app.listen(8080); sse.ts 12345678910111213import * as SSEStream from 'ssestream';import { Response, Request } from 'express';export default function (callback: (stream: SSEStream) =&gt; void) { return (req: Request, res: Response) =&gt; { res.setHeader('Access-Control-Allow-Origin', '*'); const stream = new SSEStream(req); stream.pipe(res); callback(stream); }} 1.3. Client-Sideindex.html 1234const es = new EventSource('http://localhost:8080/sse');es.onmessage = (event) =&gt; { console.log(event);} 2. Cookie 전송 [Client-Side] EventSource 생성할 때 옵션으로 { withCredentials: true }를 넣어준다. [Server-Side] Access-Control-Allow-Origin 헤더를 *이 아닌 특정 도메인으로 설정한다. [Server-Side] Access-Control-Allow-Credentials 헤더의 값을 true로 해준다. 3. 각 이벤트마다 ID 부여서버에서 SSEStream에 write할 때 id를 넣어주면 된다. 1234stream.write({ id: Date.now().toString(), data: 'Hello, World!',}); 클라이언트에서는 event.lastEventId를 통해 접근한다. 123es.onmessage = (event) =&gt; { console.log(event.lastEventId, event.data);} 4. 각 이벤트마다 타입 부여서버에서 SSEStream에 write할 때 event를 넣어주면 된다. 12345stream.write({ id: Date.now().toString(), data: 'Hello, World!', event: (Math.random() &gt; 0.5) ? 'event1' : 'event2',}); 클라이언트에서는 onmessage가 아닌 addEventListener를 통해 이벤트를 받는다. 123456es.addEventListener('event1', (event) =&gt; { console.log('event1', event.lastEventId, event.data);});es.addEventListener('event2', (event) =&gt; { console.log('event2', event.lastEventId, event.data);}); 5. Client에서 연결 종료1es.close(); 서버에서 Client가 연결을 종료한 것을 알아내려면 아래와 같이 하면 된다. 123req.socket.on('close', () =&gt; { // 연결 종료}); Server에서도 연결을 종료할 시 위의 콜백함수가 호출되는 한계가 있다. 6. Server에서 연결 종료123req.socket.end();// 또는res.socket.end(); Client에서 서버가 연결을 종료한 것을 알아내려면 아래와 같이 하면 된다. 123456es.onerror = (event) =&gt; { if (event.eventPhase === es.CLOSED) { es.close(); // 연결 종료 }} 여기서 es.close()를 하지 않으면 Client에서 무한정으로 Server에 접속 시도를 하게 된다. 7. Nginx를 통해 통신 (proxy_pass를 사용하는 경우)1proxy_buffering off; 를 location block에 추가해주면 된다. 또는 1X-Accel-Buffering: no 를 Server에서 보내는 Response에 헤더로 추가하면 된다.","link":"/Server/Node-Server-Sent-Event/"},{"title":"크롬에서 나만의 검색 엔진 사용하기","text":"크롬에서 나만의 검색 엔진 사용하기 개발자 여러분들은 구글링음 엄청 하고 계시리라 믿어 의심치 않습니다.저도 그렇거든요 ㅎㅎ 많은 사람들이 구글 홈페이지에 들어가서 검색 하는 것이 아니라 바로 크롬 주소창에 키워드를 입력해서 검색하시는데요 우리는 요걸 이용해서 더 편한 검색 라이프를 즐겨보도록 하겠습니다. 여기서는 예시를 유튜브로 하도록 하겠습니다. 크롬 설정에 들어갑니다. 기타 검색엔진에서 추가를 누릅니다. 위와 같이 입력하고 URL에 아래와 같이 입력합니다https://www.youtube.com/results?search_query=%s 키워드는 우리가 이 엔진을 쓴다고 크롬에게 알리는 문구 입니다.자세한건 밑의 gif 영상을 봐주세요 URL에서 %s는 우리가 검색할 키워드가 들어가는 부분입니다. 위의 두 옵션을 이용해서 다양한 검색엔진을 만드시면 됩니다. 검색창에 유튜브를 입력하고 탭을 누르면 유튜브 검색 모드로 넘어갑니다. 저는 이 기능을 이용하여 Github, 영어사전, 나무위키 등에 사용하고 있습니다.","link":"/etc/Chrome-Custom-Search-Engine/"},{"title":"슬랙과 깃허브 연동하기","text":"슬랙과 깃허브 연동하기 목차1. Slack에 Github 앱 추가하기2. Github Repository와 연동하기3. Slack에서 Github Issue 만들기 1. Slack에 Github 앱 추가하기먼저 좌상단의 워크스페이스 이름을 클릭한 후 Administration - Manage apps를 클릭합니다. Browse the App Directory를 누릅니다. 만약 이전에 설치해 놓은 앱이 있으면 아래의 사진과 같이 뜨는데 그러면 App Directory를 누릅니다. github를 검색한 후 맨 처음에 나온 Github를 클릭합니다. Legacy가 적힌 것은 Enterprise 계정 전용이라고 합니다. Install을 누릅니다. Continue를 누릅니다. 이 Github 앱을 사용할 채널을 선택하는데 저와같이 원하는 채널만 선택하셔도 되고, 모든 채널을 선택하셔도 됩니다. 나중에 채널을 추가 할 수 있습니다. 여기서 선택 되지 않은 채널에서는 Github와의 연동을 할 수 없습니다. 설치를 하게 되면 위와 같이 좌하단의 Apps에 Github가 추가된 것을 알 수 있습니다. 2. Github Repository와 연동하기 /github subscribe [연동하고 싶은 Repository URL]원하는 채널에 가서 위와 같은 명령어를 입력합니다. 그러면 위와 같이 Github account를 연결해달라는 요청이 뜹니다. `Authorize Slack By Github`를 클릭하면 됩니다. 연결을 원하는 Repository의 계정을 클릭합니다. 원하는 Repository를 선택합니다. 그려면 위와 같이 Repository와의 연결이 성공했다는 메시지가 뜹니다. 이 Repository에 누군가 Commit을 하고 Push를 한다면 위와 같은 커멧 메시지가 뜹니다. 3. Slack에서 Github Issue 만들기 /github open [Issue를 만들고 싶은 Repository URL]Issue를 만들고 싶은 Repository를 위와 같이 입력합니다. 그러면 위와 같이 Issue를 만들 수 있는 창이 뜹니다. 원하는 정보를 입력한 후 `Open`을 누릅니다. 그러면 위와 같이 Issue가 만들어졌다고 뜹니다. 실제 Github에 가서도 정상적으로 Issue가 생성된 것을 알 수 있습니다. /github help 명령어를 통해 어떤 명령어가 있는지 알 수 있습니다.","link":"/etc/Slack-Github-Integration/"},{"title":"낮은 Swift 버전을 쓰는 라이브러리 CocoaPod에서 사용하기","text":"내 프로젝트의 swift 버전 보다 낮은 버전으로 작성 되어 있는 외부 라이브러리를 사용하고 싶을 때 어떻게 해야 하는 지 알아보자 123456789101112131415pod 'LibraryName1'pod 'LibraryName2'post_install do |installer| # Your list of targets here. myTargets = ['LibraryName1', 'LibraryName2'] installer.pods_project.targets.each do |target| if myTargets.include? target.name target.build_configurations.each do |config| config.build_settings['SWIFT_VERSION'] = '3.2' end end endend LibraryName1, LibraryName2를 자신이 원하는 라이브러리 이름으로 바꾸면 된다.","link":"/iOS/Cocoa-Pod-Swift-Version/"},{"title":"커스텀 뷰 만드는 법","text":"iOS에서 커스텀 뷰를 만드는 방법을 알아보자 먼저 Cocoa Touch Class 새로운 파일을 하나 만듭니다. 원하는 커스텀 뷰의 이름을 넣습니다. 여기서는 TestView라고 했습니다. 그 다음 새로운 xib 파일을 하나 만듭니다. 이 xib 파일의 이름도 아까와 같은 이름으로 해줍시다. 반드시 그래야 되는 건 아닌데 안 헷갈리기 위해 같게 해줍시다. File’s Owner를 클릭한 다음에 아까 만들었던 Cocoa Touch Class 파일의 이름을 적습니다 그런데 지금은 root 뷰의 크기를 바꿀 수가 없습니다. root 뷰의 Property의 Size를 Freedom으로 바꿔줍시다. 그러면 root뷰의 크기를 바꿀 수 있습니다. 그 다음 자유롭게 root 뷰의 내용을 채워줍시다. 1234567891011121314151617181920212223import UIKitclass TestView: UIView { //코드에서 뷰를 생성할 때 호출 됨 override init(frame: CGRect) { super.init(frame: frame) setup() } //storyboard에 뷰를 사용할 때 호출 됨 required init?(coder aDecoder: NSCoder) { super.init(coder: aDecoder) setup() } func setup() { let view = Bundle.main.loadNibNamed(\"TestView\", owner: self, options: nil)?.first as! UIView view.frame = bounds addSubview(view) //여기에 필요한 작업을 하세요 }} 아까만든 swift 파일을 다음과 같이 채워줍시다. instanceFromNib 메서드의 nibName는 우리가 만든 xib파일의 이름과 같게 해줍시다. 이러면 커스텀 뷰 만들기 끝입니다. storyboard에서 우리가 만든 뷰를 사용 하려면 위와 같이 해줍시다. 확인 TableViewCell에서 했듯이 이렇게 화면 2개로 해서 코드에서 UI들을 다룰 수 있습니다.","link":"/iOS/How-To-Create-Custom-View/"},{"title":"Cell의 높이가 변하는 테이블 뷰 만들기","text":"Cell의 내용에 따라 높이가 변하는 TableView를 만드는 방법을 알아보자 이렇게 각 셀의 높이가 서로 다른 테이블 뷰를 만드려고 합니다. item 파일 만들기각각의 셀의 정보를 담고 있는 item파일을 만듭시다 Swift파일을 하나 만듭니다 2. TestItem 이라고 이름을 붙였습니다 123456789class TestItem { var title:String var content:String init(title:String, content:String) { self.title = title self.content = content }} Cell.swift 파일 만들기각각의 셀의 swift파일 만듭시다 Cocoa Touch Class를 하나 만든 다음에 2. Subclass of는 UICollectionViewCell을 선택하고 TestCell을 사용했습니다. 1234567891011121314151617181920212223class TestCell: UICollectionViewCell { static var measureView = Bundle.main.loadNibNamed(String(describing: TestCell.self), owner: nil, options: nil)?.first as! TestCell @IBOutlet weak var titleLabel: UILabel! @IBOutlet weak var contentLabel: UILabel! @IBOutlet weak var rootWidth: NSLayoutConstraint! var item: TestItem! func setItem(_ item: TestItem) { self.item = item titleLabel.text = item.title contentLabel.text = item.content } static func getDynamicHeight(of width: CGFloat, item:TestItem) -&gt; CGFloat { measureView.setItem(item) measureView.rootWidth.constant = width let newSize = measureView.systemLayoutSizeFitting(UILayoutFittingCompressedSize) return newSize.height }} measureView는 각의 cell의 높이를 구할 때 사용하는 테스트용 Cell입니다. 이를 이용해서 getDynamicHeight 함수에서 width와 item이 주어지면 이를 measureView에 넣어서 나오는 height를 반환해 줍니다. Cell.xib 파일 만들기각각의 셀의 xib파일 만듭시다 Empty xib파일을 하나 만듭니다 2. TestCell이라고 swift파일의 이름과 똑같이 붙였습니다 3. CollectionViewCell을 넣습니다 4. 그 안에 View를 넣습니다 5. 이 View의 constraint를 위와 같이 합니다 6. label을 2개 넣습니다 7. 두 label의 폰트와 폰트 색과 폰트 크기와 배경등을 적당히 하고 Lines를 0으로 해야 합니다! 8. Title label의 constraint를 위와 같이 합니다 9. Content label의 constraint를 위와 같이 합니다 10. 그러면 위와 같이 빨간색으로 conflict가 생겼다고 할 겁니다 11. CollectionViewCell을 선택해서 적당히 conflict가 없어지는 Height로 설정합니다. 12. 가장 root인 View의 width constraint를 넣습니다. 13. CollectionViewCell을 선택하고 Class를 TestCell로 합니다. 14. titleLabel과 contentLabel과 width를 outlet과 연결합니다 TestTableView 만들기이제 이 셀들을 보여주는 TableView 가 필요합니다. 우리는 PagingTableView를 사용 할 겁니다. 이건 제가 만든 건데 어떻게 구현 되어 있는지는 이해 안 하셔도 됩니다. 2. Swift파일을 만듭니다 3. TestTableView라고 이름을 붙였습니다. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import UIKitimport Foundationclass TestTableView: PagingTableView, PagingTableViewDelegate, PagingTableViewDataSource { func initialize(nowVC: UIViewController) { super.columnNum = 1 //테이블의 열의 개수를 나타냄 super.sectionInset = CGFloat(8) //Cell과 바깥과의 여백 super.itemSpacing = CGFloat(8) //각 Cell사이의 간격 super.delegate = self super.initialize(nowVC: nowVC, dataSource: self) } func setItem(cell: UICollectionViewCell, item: Any) -&gt; UICollectionViewCell { if let cell = cell as? TestCell { if let item = item as? TestItem { cell.setItem(item) } } return cell } func loadMoreItems(page: Int, callback: @escaping ([Any]) -&gt; Void) { var items:[TestItem] = [] items.append(TestItem(title:\"title\", content:\"content\")) items.append(TestItem(title:\"랜섬웨어 7천만원 행방은? 배후 꼬리잡힐 가능성 있나\", content:\"물밑 사이버 추격전 예고…\\\"현실화폐 교환 땐 추적될 수도\\\"비트코인 간판[EPA=연합뉴스](서울=연합뉴스) 김수진 기자\")) items.append(TestItem(title:\"517건→2863건→1256건…기세 꺾인 랜섬웨어\", content:\"관련 문의 15일 정점 찍고 하락세\\\"2차 공격 가능성 있어 안심은 일러\\\"[아시아경제 김동표 기자]랜섬웨어 워너크라이(WannaCry)의 기세가 대폭 꺾였다\")) items.append(TestItem(title:\"오픈소스 저작권 위반혐의 한컴, 美 법정행… \\\"문제 간단치 않다\\\" 우려\", content:\"한글과컴퓨터(www.hancom.com 대표 김상철·이원필, 이하 한컴)가 오픈소스 라이선스 위반으로 국제소송에 휘말려 미국 법정에 서게 될 위기에 빠졌다.미국 온라인매체 쿼츠는 지난\")) items.append(TestItem(title:\"title title title title\", content:\"content content content content\")) callback(items) } func getNibName() -&gt; String { return String(describing: TestCell.self) } func didSelected(item: Any) { print(\"selected! \\(item)\") } func calcHeight(width:CGFloat, item:Any) -&gt; CGFloat { return TestCell.getDynamicHeight(of: width, item: item as! TestItem) }} func initialize(nowVC: UIViewController) 초기화 하는 함수입니다 여기서 columnNum은 테이블의 열의 갯수 sectionInset은 셀과 바깥 테이블과의 간격 itemSpacing은 셀 사이의 간격을 나타냅니다 func setItem(cell: UICollectionViewCell, item: Any) -&gt; UICollectionViewCell 주어진 item을 가지고 주어진 cell에 데이터를 넣습니다 func loadMoreItems(page: Int, callback: @escaping ([Any]) -&gt; Void) page가 주어지면 이 page가지고 Item을 만들어서 callback함수를 실행시킵니다 func getNibName() -&gt; String 이 테이블에 사용하는 xib파일의 이름을 반환해 주는 함수 입니다. func didSelected(item: Any) 만약에 셀이 클릭되었을 때 실행되는 함수입니다. func calcHeight(width:CGFloat, item:Any) -&gt; CGFloat 주어진 width와 item이 있을 때 셀의 높이를 반환해 주는 함수입니다. ViewController에서 사용하기이제 이 셀들을 보여주는 TableView 가 필요합니다. Main.storyboard에 적당히 색을 칠한 view를 넣고 CustomClass를 TestTableView로 합니다. 123456789101112131415161718import UIKitclass ViewController: UIViewController { @IBOutlet weak var testTableView: TestTableView! override func viewDidLoad() { super.viewDidLoad() // Do any additional setup after loading the view, typically from a nib. testTableView.initialize(nowVC: self) } override func didReceiveMemoryWarning() { super.didReceiveMemoryWarning() // Dispose of any resources that can be recreated. }} ViewController파일에 위와 같이 하고 testTabelView와 storyboard상의 그 것과 연결해 줍니다 결과 columnNum이 2일 경우 columnNum이 1일 경우","link":"/iOS/How-to-Create-Paging-Table-View/"},{"title":"iOS에서 Naver Clova Speech Synthesis(CSS) 사용하기","text":"iOS에서 Naver Clova Speech Synthesis(CSS) 사용해서 audio를 text로 바꾸는 방법을 알아보자 1. CSSTest라는 이름의 프로젝트를 만듭니다. 여기서 Bundle Identifier는 뒤에서 쓰이니 기억해둡시다. 2. 네이버 개발자 센터에 가서 새로운 어플리케이션을 등록하는 페이지로 갑니다. 3. 휴대폰 인증을 하고 회사 이름은 아무거나 적어줍시다. 4. 어플리케이션 이름은 아무거나 적어도 상관 없습니다. 저는 CSSTest 라고 적었습니다. 그리고 사용 API에 Clova Speech Synthesis를 선택하고 iOS환경을 추가해서 1번의 Bundle Identifier를 적습니다. 5. 그러고 나면 이렇게 Client ID와 Client Secret이 보이는 페이지로 넘어갑니다. 이 두 개는 뒤에서 쓰이니 기억해둡시다. 12345678910111213141516171819202122232425262728293031323334353637383940import UIKitimport Alamofireimport AVFoundationclass ViewController: UIViewController { let URL = \"https://openapi.naver.com/v1/voice/tts.bin\" let headers: HTTPHeaders = [ \"Content-Type\": \"application/x-www-form-urlencoded; charset=UTF-8\", \"X-Naver-Client-Id\": \"아까 봤던 Client ID\", \"X-Naver-Client-Secret\": \"아까 봤던 Client Secret\" ] let parameters: Parameters = [ \"speaker\": \"clara\", \"speed\": 0, \"text\": \"hello, world.\" ] var player = AVPlayer() override func viewDidLoad() { super.viewDidLoad() Alamofire.request(URL, method: .post, parameters: parameters, headers: headers).response { response in guard let data = response.data as NSData? else { return } let audioFileURL = self.save(data: data, fileName: \"css.mp3\") let playerItem = AVPlayerItem(url: audioFileURL as URL) self.player = AVPlayer(playerItem:playerItem) self.player.play() } } func save(data: NSData, fileName: String) -&gt; NSURL { let path = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)[0] as String let fullPath:String = (path as NSString).appendingPathComponent(fileName) data.write(toFile: fullPath, atomically: true) return NSURL(fileURLWithPath: fullPath) }} 6. 아까 만들었던 프로젝트의 ViewController에 위와 같이 적어줍시다. X-Naver-Client-Id와 X-Naver-Client-Secret에 위에서 봤던 Client ID와 Client Secret을 각각 적어줍니다. 저는 Alamofire를 이용해서 mp3파일을 받아왔습니다. 다른 방법을 사용해도 상관 없습니다. 위 코드는 받은 mp3파일을 css.mp3로 앱 내 documentDirectory에 저장 후 재생하는 코드입니다. 이제 앱을 실행하면 “hello, world” 라는 clara의 목소리가 들릴 것입니다.","link":"/iOS/Naver-Clova-Speech-Synthesis/"},{"title":"내 서버에 Https 적용하기 (Nginx)","text":"무료 HTTPS 인증서 발급 기관인 Let’s Encrypt를 통해 내 서버에 Https를 적용하는 법을 알아보겠습니다. 목차1. Certbot 설치2. 인증서 발급3. Nginx 설정4. 인증서 갱신5. Crontab에 등록6. 내 사이트 테스트 인증서를 얻기 위해서는 해당 서버에 SSH로 접속해야 합니다. 1. Certbot 설치Certbot은 Let’s Encrypt의 인증서 발급을 편하게 도와주는 도구 입니다. Certbot을 설치하기 위해서는 다음과 같은 명령어를 입력해 주시길 바랍니다. 123456$ sudo apt-get update$ sudo apt-get install software-properties-common$ sudo add-apt-repository universe$ sudo add-apt-repository ppa:certbot/certbot$ sudo apt-get update$ sudo apt-get install certbot 2. 인증서 발급인증서 발급은 인증 기관(여기서는 Let’s Encrypt)이 인증서 발급을 요청한 서버가 실제로 이 도메인을 소유하고 있는 지를 검증하기 위해 요청 도메인의 특정 Path에 특정 내용을 담아보라고 요구합니다. 예를 들어 hyunsub.kim에 대한 인증서를 요청하면 인증 기관은 http://hyunsub.kim/1q2w3e4r에 ‘asdfqwer’를 담아보라고 요구하고 이 것을 수행하면 이 도메인을 소유하고 있다고 판단하는 것입니다. 따라서 certbot이 이러한 작업을 할 수 있도록 명령어를 입력하는데 크게 2가지 경우가 있습니다. 2.1. 80 포트에 돌아가는 웹 서버를 잠시 정지 시킬 수 있는 경우1$ sudo certbot certonly -d www.example.com --standalone certbot이 독자적인 웹 서버를 80 포트에 돌려서 위의 인증 기관의 요구 사항을 수행합니다. 2.2. 80 포트에 돌아가는 웹 서버를 잠시 정지 시킬 수 없는 경우1$ sudo certbot certonly -d www.example.com --webroot -w /var/www/example 만약에 80 포트에 돌아가는 웹 서버를 정지할 수 없는 경우 webroot 폴더 경로를 지정해 주면서 인증 기관의 요구 사항을 수행하게 합니다. 여기서 w 옵션의 값으로 들어간 /var/www/example 폴더가 webroot 폴더인데 예를 들어 /var/www/example/tmp.txt 에 파일을 생성하면 http://www.example.com/tmp.txt로 접근할 수 있게 웹 서버 설정이 된 폴더를 webroot 폴더라고 합니다. 2.3. Finally위의 명령어를 입력하고 나면 아래의 경로에 두 파일이 만들어집니다. /etc/letsencrypt/live/{도메인 주소}/fullchain.pem (인증서 + 공개키 파일) /etc/letsencrypt/live/{도메인 주소}/privkey.pem (개인키 파일) 이제 이 두 파일을 Nginx에 적용시켜 보겠습니다. 3. Nginx 설정12345678910111213141516171819202122server { listen 80 default; server_name home.hyunsub.kim; location / { return 301 https://home.hyunsub.kim$request_uri; }}server { listen 443 ssl default; server_name home.hyunsub.kim; ssl_certificate /etc/letsencrypt/archive/home.hyunsub.kim/fullchain1.pem; ssl_certificate_key /etc/letsencrypt/archive/home.hyunsub.kim/privkey1.pem; location / { root /usr/share/nginx/html; index index.html; try_files $uri $uri/ /index.html; }} 4. 인증서 갱신Let’s Encrypt 인증서는 3개월 후에 만료되므로 주기적으로 갱신시켜주어야 합니다. 인증서 갱신은 인증서 발급과 같은 과정을 거치기 때문에 80 포트를 쓸 수 있냐 없냐로 나뉘어서 명령어를 입력해야 합니다. 4.1. 80 포트에 돌아가는 웹 서버를 잠시 정지 시킬 수 있는 경우12$ sudo certbot renew --pre-hook \"service nginx stop\" --post-hook \"service nginx start\"$ sudo certbot renew --pre-hook \"service nginx stop\" --post-hook \"service nginx start\" --dry-run # 갱신 테스트 prehook, posthook을 통해 갱신 전에 웹 서버를 잠시 정지시키고 인증서 갱신한 다음 다시 웹 서버를 실행시킵니다. 4.2. 80 포트에 돌아가는 웹 서버를 잠시 정지 시킬 수 없는 경우하는 중… 5. Crontab에 등록Crontab에 다음과 같이 추가해서 주기적으로 인증서 갱신을 하도록 합니다. 10 0 1 * * sudo certbot renew ... 매달 1일 0시에 인증서를 갱신한다는 의미입니다. 하지만 인증서 갱신은 인증서 만료 30일 전부터 가능한다는 점 알아두셔야 합니다. 6. 내 사이트 테스트아래 사이트를 통해 내 사이트의 HTTPS를 검증할 수 있습니다. https://www.ssllabs.com/ssltest/","link":"/Server/HTTPS/"},{"title":"ElasticSearch - Index 편","text":"ElasticSearch - Index 편 모든 문서는 6.5.0 버전 기준으로 작성 되었습니다.1. Index 만들기1$ curl -XPUT http://localhost:9200/twitter 1.1. Index 이름 규칙 소문자만 사용 가능 \\, /, *, ?, &quot;, &lt;, &gt;, |, (space character), ,, # 사용 불가 7.0 이전 버전에서는 :을 사용할 수 있지만 그 이후 버전에서는 사용 불가 -, _, +로 시작할 수 없음 . 또는 .. 으로 지을 수 없음 255 바이트 보다 길게 지을 수 없음 (한글 같은 경우는 한 글자에 1 바이트 보다 크므로 지을 수 있는 글자 수는 더 적음) 1.2. Setting과 함께 Index 만들기12345678910$ curl -XPUT http://localhost:9200/twitter -H \"Content-Type:application/json\" -d '{ \"settings\" : { \"index\" : { \"number_of_shards\" : 3, \"number_of_replicas\" : 2 } }}' 다음도 가능합니다. 123456{ &quot;settings&quot; : { &quot;number_of_shards&quot; : 3, &quot;number_of_replicas&quot; : 2 }} number_of_shards의 기본값은 5입니다. number_of_replicas의 기본값은 1입니다. (각 primary shard 당 1개의 복사본) 1.3. Mapping과 함께 Index 만들기1234567891011$ curl -XPUT http://localhost:9200/test -H \"Content-Type:application/json\" -d '{ \"mappings\" : { \"_doc\" : { \"properties\" : { \"field1\" : { \"type\" : \"text\" } } } }}' 1.4. 별명 (Aliase)과 함께 Index 만들기12345678910111213$ curl -XPUT http://localhost:9200/test -H \"Content-Type:application/json\" -d '{ \"aliases\" : { \"alias_1\" : {}, \"alias_2\" : { \"filter\" : { \"term\" : {\"user\" : \"kimchy\" } }, \"routing\" : \"kimchy\" } }}' 위의 Setting, Mapping, Aliase는 동시에 설정 할 수 있습니다.","link":"/Server/ElasticSearch-Index/"},{"title":"Elastic Stack - Kibana 편","text":"정형 및 비정형 데이터를 시각화하고 분석하는데 용이한 Elastic Stack을 사용하는 법을 알아보겠습니다. 이 글은 Ubuntu 18.04.2 LTS 사용자를 대상으로 작성했습니다. 목차1. Kibana 설치2. Elasticsearch와 연동하기3. 실행하기4. 로그 보기5. Elasticsearch 데이터 보기6. 80번 포트로 실행시키기 1. Kibana 설치1) Kibana를 다운로드 받습니다.1$ wget https://artifacts.elastic.co/downloads/kibana/kibana-6.5.0-amd64.deb 다른 버전의 설치 링크를 알고 싶으시다면 https://www.elastic.co/kr/downloads/past-releases를 방문하시면 됩니다. URL의 6.5.0 부분을 원하시는 버전으로 바꾸시면 그 버전이 다운로드 됩니다. Kibana 6.0.0 이상의 버전은 64bit 운영체제만 지원합니다 2) dpkg 명령어를 이용해 Kibana를 설치합니다.1$ sudo dpkg -i kibana-6.5.0-amd64.deb Kibana는 다음과 같은 위치에 설치 됩니다. 내용 위치 설치 경로 /usr/share/kibana 설정 파일 경로 /etc/kibana 데이터 저장 경로 /var/lib/kibana 실행 파일 경로 /etc/init.d/kibana 3) 서버가 시작 될 때 자동으로 시작되게 설정합니다.1$ sudo systemctl enable kibana.service 4) option : Kibana 삭제 방법 12$ sudo dpkg --purge kibana$ find / -name kibana -exec rm -r \"{}\" \\; 2. Elasticsearch와 연동하기Elasticsearch와 Kibana를 같은 서버에서 구동하면 딱히 설정할 게 없지만 다른 서버에서 구동하면 /etc/kibana/kibana.yml을 수정해야 합니다. 파일에서 아래의 부분을 본인의 Elasticsearch 서버의 주소로 바꾸시고 앞의 주석 처리를 없앱니다. 1#elasticsearch.url: &quot;http://localhost:9200&quot; 3. 실행하기12345# Kibana 시작 명령어$ sudo service kibana start# Kibana 중지 명령어$ sudo service kibana stop 아래 링크에 웹브라우저로 접속해서 정상적으로 실행이 되었는지 알 수 있습니다. Kibana 시작 되는 데 시간이 좀 걸리므로 1분 정도 지나서 시도해 주시길 바랍니다. 1$ curl -v http://localhost:5601 아래와 같이 뜨면 실행이 되고 있다는 뜻입니다. 1234567891011121314151617181920Note: Unnecessary use of -X or --request, GET is already inferred.* Rebuilt URL to: http://localhost:5601/* Trying 127.0.0.1...* TCP_NODELAY set* Connected to localhost (127.0.0.1) port 5601 (#0)&gt; GET / HTTP/1.1&gt; Host: localhost:5601&gt; User-Agent: curl/7.58.0&gt; Accept: */*&gt; &lt; HTTP/1.1 302 Found&lt; location: /app/kibana&lt; kbn-name: kibana&lt; kbn-xpack-sig: fd6e658a000b1fdd8c1408d85da429b6&lt; cache-control: no-cache&lt; content-length: 0&lt; connection: close&lt; Date: Tue, 21 May 2019 13:45:43 GMT&lt; * Closing connection 0 4. 로그 보기Kibana는 기본적으로 로그를 파일에 저장하는 것이 아니라 stdout에 출력하므로 로그를 보시려면 다른 방법을 사용해야 합니다 Kibana의 로그를 보고 싶다면 아래의 명령어를 입력하시면 됩니다. 1$ journalctl -u kibana.service -e 또는 Kibana의 설정파일을 수정하시면 됩니다. /etc/kibana/kibana.yml 1logging.dest: /var/log/kibana.log 5. Elasticsearch 데이터 보기 Management - Index Pattern을 클릭합니다. Index Pattenr을 records라고 입력하고 다음으로 넘어갑니다. Time filter field name을 time이라고 설정하고 완료합니다. Discover에 들어가서 우측 상단의 시간을 적절히 조정하시면 우리가 저번에 넣었던 데이터 1000개를 볼 수 있습니다. 6. 80번 포트로 실행시키기/etc/kibana/kibana.yml에서 포트를 그냥 80번으로 변경한 뒤 실행하면 그 포트를 사용하지 못한다는 에러가 발생합니다. sudo service kibana start 명령어가 Kibana를 root 권한으로 실행시키지 않아서 발생하는 에러 입니다. 따라서 service가 Kibana를 root 권한으로 실행시키도록 수정해야 합니다. 123456789101112131415$ sudo vi /etc/kibana/kibana.ymlserver.port: 80로 변경$ sudo vi /etc/systemd/system/kibana.serviceUser=rootGroup=root로 변경$ sudo systemctl daemon-reload$ sudo service kibana start","link":"/Server/ELK-2/"},{"title":"웹에 있는 오디오 재생하기","text":"웹에 있는 오디오를 재생하는 방법을 알아보자 1. 프로젝트의 Info.plist에 App Transport Security Settings를 추가합니다. 그리고 그 안에 Allow Arbitrary Loads를 추가하고 그 값을 YES로 바꿔줍니다. 12345678910111213import UIKitimport AVFoundationclass ViewController: UIViewController { var player = AVPlayer() override func viewDidLoad() { let url = \"http://radio.spainmedia.es/wp-content/uploads/2015/12/tailtoddle_lo4.mp3\" let playerItem = AVPlayerItem(url: NSURL(string: url)! as URL) player = AVPlayer(playerItem: playerItem) player.play() }} 2. 위와 같이 하면 저 URL의 mp3파일이 재생됩니다.","link":"/iOS/Play-Audio-From-Web/"},{"title":"Android에서 네이버 지도 SDK 사용하기","text":"Android에서 네이버 지도 SDK 사용하기 목차1. 앱 등록하기2. 준비하기3-1. Activity에서 네이버 지도 사용하기3-2. Fragment에서 네이버 지도 사용하기4. 지도 배율 설정하기5. 지도에 마커 표시하기 1. 앱 등록하기 NaverMapExample 이라는 이름으로 프로젝트를 하나 만들었습니다. minimum SDK는 19로 했습니다. 네이버 개발자 센터에 가서 로그인을 하고 어플리케이션 등록을 누릅니다. 어플리케이션 이름은 실제 사용자들이 보게 될 서비스 이름입니다. 뭐 우리는 이 앱을 실제로 서비스하지 않으므로 적당히 입력합니다.사용 API에서 지도(모바일)을 선택하고 Android 환경을 추가한 뒤 안드로이드 앱 패키지 이름을 입력한 뒤 등록합니다. 등록을 하고 나면 위와 같이 Client ID와 Client Secret을 볼 수 있습니다. Client ID만 쓰이므로 Client Secret는 신경 쓰지 말도록 합시다. 2. 준비하기App Level의 build.gradle의 dependencies에 아래의 내용을 추가합나디. 1implementation 'com.naver.maps.open:naver-map-api:2.1.2@aar' AndroidManifest.xml의 manifest 태그 안에 아래의 내용을 추가합니다. 12345&lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;!--반드시 추가--&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"/&gt; &lt;!--위치정보활용시 추가--&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"/&gt; &lt;!--위치정보활용시 추가--&gt;&lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\"/&gt; &lt;!--WIFI 상태활용시 추가--&gt;&lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\"/&gt; &lt;!--WIFI 상태활용시 추가--&gt; 3-1. Activity에서 네이버 지도 사용하기NMapView : 안드로이드 ViewGroup 클래스를 상속받은 클래스로서 지도 데이터를 화면에 표시합니다. activity_main.xml 1234567891011&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\"&gt; &lt;com.nhn.android.maps.NMapView android:id=\"@+id/map_view\" android:layout_width=\"360dp\" android:layout_height=\"360dp\"/&gt;&lt;/LinearLayout&gt; MainActivity.kt 1234567891011class MainActivity : NMapActivity() { private val clientId = \"YOUR_CLIENT_ID\" override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) map_view.setClientId(clientId) map_view.isClickable = true }} NMapView는 clickable이 false로 초기화 되어 있으므로 지도 이동 및 확대가 전혀 되지 않습니다. 따라서 isClickable을 true로 만들어 주어야 합니다. 앱을 실행하면 아래와 같이 나옵니다. NMapActivity는 AppCompatActivity를 상속하는 것이 아니므로 툴바가 나오지 않는다는 사실을 알 수 있습니다. 3-2. Fragment에서 네이버 지도 사용하기Fragment에서 NMapView를 사용하려면 아래와 같이 모든 lifecycle 마다 NMapContext를 호출해야 합니다. MainFragment.kt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class MainFragment : Fragment() { private val clientId = \"YOUR_CLIENT_ID\" private lateinit var mMapContext: NMapContext override fun onCreateView(inflater: LayoutInflater, container: ViewGroup?, savedInstanceState: Bundle?): View? { return inflater.inflate(R.layout.activity_main, container, false) } override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) mMapContext = NMapContext(super.getActivity()) mMapContext.onCreate() } override fun onActivityCreated(savedInstanceState: Bundle?) { super.onActivityCreated(savedInstanceState) map_view.setClientId(clientId) mMapContext.setupMapView(map_view) } override fun onStart() { super.onStart() mMapContext.onStart() } override fun onResume() { super.onResume() mMapContext.onResume() } override fun onPause() { super.onPause() mMapContext.onPause() } override fun onStop() { mMapContext.onStop() super.onStop() } override fun onDestroy() { mMapContext.onDestroy() super.onDestroy() }} 4. 지도 배율 설정하기 앱 실행 화면을 보시면 너무 지도 요소들이 작은 것을 알 수 있습니다. 가져온 지도의 1픽셀을 기기 화면의 1픽셀에 대응시켜서 보여주기 때문입니다. 따라서 NMapView의 다음 메서드를 이용하여 지도를 적절히 확대시켜야 합니다. 1boolean setScalingFactor(float scalingFactor, boolean mapHD) 하지만 여기서의 scalingFactor는 단순히 확대 시키는 비율이므로 화면의 density에 따라 적절히 정해주어야 합니다. 다음 예시를 보시면 이해가 되실것입니다. 1) scalingFactor를 3.0으로 했을 경우 xxhdpi (1920 x 1080) xxxhdpi (2560 * 1440) 2) scalingFactor를 context.resources.displayMetrics.density로 했을 경우 xxhdpi (1920 x 1080) xxxhdpi (2560 * 1440) 3) mapHD의 비교 mapHD = true mapHD = false 5. 지도에 마커 표시하기NMapResourceProvider는 지도 위의 오버레이 객체 드로잉에 필요한 리소스 데이터를 제공하기 위한 추상 클래스입니다. 따라서 지도에 뭔가를 표시하려면 이를 상속하는 클래스를 만들어서 사용해야 합니다. 그러므로 아래 코드를 복사하여 CustomResourceProvider를 만듭니다. 여기 있는 메서드들은 앞으로 차차 채워나갈 것입니다. CustomResourceProvider.kt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677class CustomResourceProvider(context: Context): NMapResourceProvider(context) { override fun getLocationDot(): Array&lt;Drawable&gt;? { return null } override fun getDrawableForMarker(p0: Int, p1: Boolean, p2: NMapOverlayItem?): Drawable? { return null } override fun getCalloutBackground(p0: NMapOverlayItem?): Drawable? { return null } override fun getCalloutRightButton(p0: NMapOverlayItem?): Array&lt;Drawable&gt;? { return null } override fun getCalloutTextColors(p0: NMapOverlayItem?): IntArray? { return null } override fun findResourceIdForMarker(markerId: Int, focused: Boolean): Int { return 0 } override fun getCalloutRightButtonText(p0: NMapOverlayItem?): String? { return null } override fun getCalloutRightAccessory(p0: NMapOverlayItem?): Array&lt;Drawable&gt;? { return null } override fun getDirectionArrow(): Drawable? { return null } override fun getParentLayoutIdForOverlappedListView(): Int { return 0 } override fun getOverlappedListViewId(): Int { return 0 } override fun getLayoutIdForOverlappedListView(): Int { return 0 } override fun getListItemLayoutIdForOverlappedListView(): Int { return 0 } override fun getListItemTextViewId(): Int { return 0 } override fun getListItemTailTextViewId(): Int { return 0 } override fun getListItemImageViewId(): Int { return 0 } override fun getListItemDividerId(): Int { return 0 } override fun setOverlappedListViewLayout(listView: ListView, itemCount: Int, width: Int, height: Int) { } override fun setOverlappedItemResource(poiItem: NMapPOIitem, imageView: ImageView) { }} 지도 위에 핀으로 쓸 이미지를 하나 가져옵니다. 저는 대충 24dp 크기 짜리 벡터 이미지를 하나 가져왔습니다. CustomResourceProvider의 findResourceIdForMarker를 아래와 같이 바꿉니다. 123override fun findResourceIdForMarker(markerId: Int, focused: Boolean): Int { return R.drawable.pin} MainActivity의 onCreate를 다음과 같이 수정합니다. MainActivity.kt 12345678910override fun onCreate(savedInstanceState: Bundle?) { super.onCreate(savedInstanceState) setContentView(R.layout.activity_main) map_view.setClientId(clientId) map_view.isClickable = true map_view.setScalingFactor(resources.displayMetrics.density, true) // 여기 부터 아래 내용 입력 시작} 1val resourceProvider = CustomResourceProvider(this) 지도 위의 오버레이 객체 드로잉에 필요한 리소스 데이터를 제공하는 CustomResourceProvider를 생성합니다. 1val overlayManager = NMapOverlayManager(this, map_view, resourceProvider) 지도 위에 표시되는 오버레이 객체를 관리하는 NMapOverlayManager를 생성합니다. 1val poiData = NMapPOIdata(10, resourceProvider) 지도 위에 표시되는 POI 아이템을 관리하는 NMapPOIdata를 생성합니다. 10은 전체 POI 아이템 갯수를 의미합니다. 1234poiData.beginPOIdata(2)poiData.addPOIitem(126.977983, 37.565568, \"서울광장\", 123, 0)poiData.addPOIitem(126.976715, 37.575994, \"광화문\", 123, 0)poiData.endPOIdata() NMapPOIdata에 데이터를 넣을 때는 꼭 beginPOIdata를 호출해야 합니다.beginPOIdata 파라미터는 앞으로 넣을 POIItem의 갯수입니다.123은 markderId이고 NMapResourceProvider에서 사용합니다.0은 tag이고 마커를 선택했을 때 호출되는 콜백 인터페이스에서 사용됩니다. 1val poiDataOverlay = overlayManager.createPOIdataOverlay(poiData, null) 여러 개의 오버레이 아이템을 포함할 수 있는 NMapPOIdataOverlay를 만듭니다. 123Handler().postDelayed({ poiDataOverlay.showAllPOIdata(0)}, 400) NMapPOIdataOverlay의 showAllPOIdata를 호출하여 모든 POIItem을 화면에 표시합니다. showAllPOIdata의 파라미터는 지도의 축척을 의미 합니다. 0인 경우에는 모든 마커를 표시하는 적절한 축척을 자동으로 지정하여 보여줍니다. 그런데 이 부분을 바로 실행할 경우 아래와 같이 나와서 Handler를 사용해서 실행했습니다. onStart나 onResume에서 실행해도 마찬가지라서 이와 같이 했습니다. 왜 이런지는 저도 잘 모르겠네요;; Handler를 사용한 경우 Handler를 사용하지 않은 경우","link":"/Android/Naver-Map/"},{"title":"APEX로 AWS Lambda 개발하기","text":"APEX라는 프로그램을 사용하여 AWS Lambda를 개발해 서버리스 백엔드를 구현해 보자. 1. APEX 설치하기1$ curl https://raw.githubusercontent.com/apex/apex/master/install.sh | sudo sh macOS, Linux, or OpenBSD에서 위의 명령어를 실행시키면 자동으로 설치가 됩니다. 2. APEX에 AWS 권한 부여하기APEX가 Lambda 함수들을 만들고/지우고/수정하고/실행할 수 있도록 권한을 줘야 합니다. 먼저 APEX가 필요로 하는 권한을 묶은 커스텀 정책을 만듭시다. AWS IAM로 들어가서 정책 생성을 누릅니다. json편집기에 들어가서 밑의 json을 그대로 입력해 줍시다. 그리고 Review Policy를 누릅니다. 123456789101112131415161718192021222324252627282930{ \"Version\": \"2012-10-17\", \"Statement\": [ { \"Action\": [ \"iam:CreateRole\", \"iam:CreatePolicy\", \"iam:AttachRolePolicy\", \"iam:PassRole\", \"lambda:GetFunction\", \"lambda:ListFunctions\", \"lambda:CreateFunction\", \"lambda:DeleteFunction\", \"lambda:InvokeFunction\", \"lambda:GetFunctionConfiguration\", \"lambda:UpdateFunctionConfiguration\", \"lambda:UpdateFunctionCode\", \"lambda:CreateAlias\", \"lambda:UpdateAlias\", \"lambda:GetAlias\", \"lambda:ListAliases\", \"lambda:ListVersionsByFunction\", \"logs:FilterLogEvents\", \"cloudwatch:GetMetricStatistics\" ], \"Effect\": \"Allow\", \"Resource\": \"*\" } ]} 정책의 이름을 APEX-Policy로 짓고 정책을 생성합니다. 그리고 사용자에 이 정책을 추가합니다. 기존 사용자에 정책을 추가하셔도 되고, 새로운 사용자를 만드셔도 됩니다. 사용자를 만들거나 정책을 추가하는 방법은 설명하지 않도록 하겠습니다. 아까 정책을 추가한 사용자의 정보들을 아래의 위치한 파일에 추가합니다. access_key_id와 secret_access_key는 따로 설명하지 않도록 하겠습니다. ~/.aws/credentials 123[example]aws_access_key_id = xxxxxxxxaws_secret_access_key = xxxxxxxxxxxxxxxxxxxxxxxx ~/.aws/config 123[profile example]output = jsonregion = ap-northeast-2 아래의 명령어를 실행합니다. 위에서 입력한 프로필 이름에 따라 아래의 example을 바꿔주시기 바랍니다. 이렇게 하면 APEX가 AWS_PROFILE 환경변수에 접근해서 AWS 기능들을 사용할 수 있게 됩니다. 1$ export AWS_PROFILE=example 3. 프로젝트 만들기프로젝트 폴더를 생성하고 apex init를 입력하고 프로젝트의 이름과 설명을 입력하면 프로젝트가 생성됩니다. 12$ mkdir APEX-Test &amp;&amp; cd APEX-Test$ apex init 프로젝트의 이름은 APEX-Test프로젝트의 설명은 그냥 .으로 했습니다. 이제 프로젝트 폴더를 보면 json파일과 hello라는 함수가 만들어져 있습니다. 4. 프로젝트 구조 살펴보기project.json먼저 project.json 파일을 살펴보겠습니다. role은 배포할 함수의 role을 지정해 줍니다. 이 role은 APEX가 자동으로 생성한 것입니다.memory는 배포할 함수의 메모리 제한(MB)를 나타냅니다.timeout은 배포할 함수의 시간 제한(s)을 나타냅니다.environment는 배포할 함수에서 사용할 환경 변수를 나타냅니다.위의 값들을 자유롭게 본인의 프로젝트에 맞게 변경하시면 됩니다.이 밖에도 다양한 field들이 있습니다. APEX에서는 project.dev.json, project.prod.json과 같이 다중 환경에서 개발 할 수 있는 기능 각각의 함수 폴더 안에 function.json을 넣어서 함수 마다 다른 환경을 만들어 줄 수 있는 기능 등 을 제공하고 있습니다. 자세한 정보는 프로젝트 구조 (영문)를 참고해 주세요 폴더 구조 모든 함수는 functions 폴더안에 존재해야합니다.functions 폴더 밖에 만들어 둔 파일이나 폴더들은 APEX 에서는 무시합니다. functions 폴더의 바로 sub폴더들의 이름이 람다 함수의 이름이 됩니다.특별한 설정을 하지 않는 이상 sub 폴더 안의 index.js가 람다 함수의 실행 파일이 됩니다.각각의 sub 폴더 안에서는 밖에 있는 파일에 접근 할 수 없습니다.함수를 배포 할 때에는 sub 폴더 안의 파일들만을 묶어서 배포하기 때문입니다. 12345678910111213141516171819project.jsonpackage.jsonnode_modules└── ...fun0└── index.jsfunctions├── global.js├── fun1│ ├── index.js│ ├── package.json│ └── node_modules│ └── ...└── fun2 ├── asdf.js └── index.js 위의 프로젝트 구조를 예시로 들어보겠습니다. 프로젝트에는 2개의 함수가 존재합니다. (fun1, fun2) APEX에서 함수를 배포할 때에는 fun0은 무시합니다. fun1, fun2 함수를 실행 시키면 각각의 index.js가 실행됩니다. fun1/index.js 에서는 fun1/node_modules에 접근할 수 있습니다. fun2/index.js 에서는 fun2/asdf.js에 접근할 수 있습니다. fun2 에서는 global.js에 접근할 수 없습니다. fun2 에서는 모든 node_mudules에 접근할 수 없습니다. 만약에 모든 함수에 공통적으로 사용하고 싶은 npm module이 있어도 모든 함수 각각의 폴더 안에 node_mudules를 넣어야 합니다! 이를 해결 하기 위한 방법중에 하나는 WebPack을 사용하는 것인데 다음 시간에 알려드리도록 하겠습니다. 5. 함수 생성하기그냥 단순하게 functions에 폴더 하나 만들어 주고 그 안에 index.js 파일을 만들어 주시면 됩니다. 예시로 test 폴더를 만들고 그 안에 index.js 파일을 만들어서 test라는 함수를 만들었습니다. index.js에는 아래의 코드를 넣었습니다. 1234console.log('test1234')exports.handle = function(e, ctx, cb) { cb(null, { test: 'test' })} 기본적인 람다 코드 작성법이나 설명은 하지 않도록 하겠습니다. 6. 함수 배포하고 실행하기apex deploy는 functions 폴더에 있는 함수들을 모두 배포하는 작업을 합니다.apex deploy {name}처럼 특정 한 함수만 배포 할 수도 있고,apex deploy prefix*, apex deploy *suffix처럼 *을 사용하여 특정 접두어나 접미어를 가진 함수들만 배포 할 수도 있습니다. apex invoke {name}은 {name}이란 이름을 가진 함수를 실행하는 작업을 합니다. 아까 만들었던 test 함수를 배포하고 실행한 결과입니다.AWS Lambda Console 에 들어가보시면 APEX-Test_test라는 함수가 만들어 진 것을 볼 수 있습니다. apex logs {name}를 통해 함수의 로그를 확인 할 수 있습니다.우리가 만들었던 test함수에서 콘솔에 출력했던 test1234를 확인 할 수 있습니다.이 명령어를 통해서 apex invoke를 통해 실행된 것의 로그만 확인 할 수 있는 것이 아니라 모든 로그를 확인할 수 있습니다. log 명령어는 최근 5분 안에 발생했던 로그만 보여줍니다. 더 오래된 명령어를 보고 싶거나 다른 기능의 설명은 여기에 있습니다.","link":"/Server/Lambda-APEX/"},{"title":"iOS 오토 레이아웃 파헤치기","text":"iOS 오토 레이아웃 파헤치기 목차1. Editor를 사용하면서 개꿀팁2. 코드로 Layout Constraint 생성 하기3. Stack View4. Intrinsic Content Size5. Content Hugging Priority6. Content Compression Resistance Priority 1. Editor를 사용하면서 개꿀팁Zeplin 같이 View와 View 사이의 상대 길이를 알아내는 법 한 View를 선택하고 alt 키를 누른 상태로 커서를 다른 View 위로 올리면 위와 같이 그 View 와의 거리가 나타난다. 디버깅 중에 View Hierarchy 및 Size, Property가 보고 싶을 때 View UI Hierarchy 를 클릭하면 위와 같이 View Hierarchy를 확인 할 수 있고 각각의 View 들의 Property, Size, Position 등을 확인할 수 있다. 2. 코드로 Layout Constraint 생성 하기2-1. NSLayoutConstraint을 직접 생성하기1234567NSLayoutConstraint(item: view1, attribute: .leading, relatedBy: .equal, toItem: view2, attribute: .leading, multiplier: 1.0, constant: 0.0).isActive = true 2-2. Anchor를 이용하여 생성하기1234567891011121314151617181920212223242526272829// NSLayoutYAxisAnchor : topAnchor, bottomAnchor, firstBaselineAnchor, lastBaselineAnchor, centerYAnchor// NSLayoutXAxisAnchor : leadingAnchor, trailingAnchor, leftAnchor, rightAnchor, centerXAnchor// NSLayoutDimension : heightAnchor, widthAnchor// NSLayoutYAxisAnchor, NSLayoutXAxisAnchorview1.leadingAnchor.constraint(equalTo: view2.leadingAnchor)view1.leadingAnchor.constraint(greaterThanOrEqualTo: view2.leadingAnchor)view1.leadingAnchor.constraint(lessThanOrEqualTo: view2.leadingAnchor)view1.leadingAnchor.constraint(equalTo: view2.leadingAnchor, constant: 20)view1.leadingAnchor.constraint(greaterThanOrEqualTo: view2.leadingAnchor, constant: 20)view1.leadingAnchor.constraint(lessThanOrEqualTo: view2.leadingAnchor, constant: 20)// NSLayoutDimensionview1.heightAnchor.constraint(equalToConstant: 30)view1.heightAnchor.constraint(greaterThanOrEqualToConstant: 30)view1.heightAnchor.constraint(lessThanOrEqualToConstant: 30)view1.heightAnchor.constraint(equalTo: view2.heightAnchor, multiplier: 2.0)view1.heightAnchor.constraint(greaterThanOrEqualTo: view2.heightAnchor, multiplier: 2.0)view1.heightAnchor.constraint(lessThanOrEqualTo: view2.heightAnchor, multiplier: 2.0)view1.heightAnchor.constraint(equalTo: view2.heightAnchor, constant: 20)view1.heightAnchor.constraint(greaterThanOrEqualTo: view2.heightAnchor, constant: 20)view1.heightAnchor.constraint(lessThanOrEqualTo: view2.heightAnchor, constant: 20)view1.heightAnchor.constraint(equalTo: view2.heightAnchor, multiplier: 2.0, constant: 20)view1.heightAnchor.constraint(greaterThanOrEqualTo: view2.heightAnchor, multiplier: 2.0, constant: 20)view1.heightAnchor.constraint(lessThanOrEqualTo: view2.heightAnchor, multiplier: 2.0, constant: 20) 2-3. Visual Format을 이용하여 생성하기1234567891011121314151617181920212223let redView = UIView(frame: view.bounds)let blueView = UIView(frame: view.bounds)let greenView = UIView(frame: view.bounds)let views = [\"redView\": redView, \"blueView\": blueView, \"greenView\": greenView]let format1 = \"V:|-[redView]-8-[greenView]-|\"let format2 = \"H:|-[redView]-8-[blueView(==redView)]-|\"let format3 = \"H:|-[greenView]-|\"var constraints = NSLayoutConstraint.constraints(withVisualFormat: format1, metrics: nil, views: views)constraints += NSLayoutConstraint.constraints(withVisualFormat: format2, metrics: nil, views: views)constraints += NSLayoutConstraint.constraints(withVisualFormat: format3, metrics: nil, views: views)NSLayoutConstraint.activate(constraints) 3. Stack View 위와 같이 라벨들의 최대 길이 만큼 UIImageView가 밀리는 UI를 구현한다고 가정하자. 어떤 방식으로 구현해야 할까? 다양한 방법이 있겠지만 UIStackView를 사용하면 간단하게 구현할 수 있다. UIImageView의 위치를 UIStackView의 Trailing에 연결하면 된다. UIStackView의 Width는 별도의 Constraint없이 안의 View들의 크기에 따라 자동으로 결정되기 때문이다. Stack View 생성/해제 하기 위와 같이 여러 개의 View를 선택한 다음 아래의 저 버튼을 누르면 위와 같이 선택 했던 View를이 연결되면서 StackView로 감싸집니다. View hierarchy는 위와 같습니다. StackView를 해제하려면 alt 키를 누른 상태로 Stack 버튼을 누른 뒤, Unembed 버튼을 누르면 됩니다 Stack View의 ConstraintStack View도 다른 View들과 마찬가지로 X Position, Y Position, Width, Height가 Constraint로 지정이 되어야 한다. UILabel들로만 이루어진 UIStackView는 각각의 UILabel의 사이즈를 추정할 수 있기 때문에 X, Y Position Constraint만 있어도 되지만 UIView로 이루어진 UIStackView와 같은 경우에는 각각의 사이즈를 추정할 수 없기 때문에 위와 같이 UIStackView안의 각각의 View마다 Width와 Height Constraint를 넣어주어 StackView가 자신의 크기를 계산할 수 있게 해야 한다. StackView가 자신의 크기를 계산할 수 있다면 굳이 모든 View에 Width와 Height Constraint를 넣지 않아도 된다. 위와 같은 경우에는 첫 번째, 두 번째 View는 Width Constraint만 마지막 View는 Width, Height Constraint를 넣어주었다. Editor에서나 실제 앱을 구동할 때나 잘 동작한다. 만일 위처럼 각각의 View에 Width, Height Constraint를 넣지 않고 그냥 StackView에 Width, Height Constraint를 넣어주면 StackView에는 모호성이 없다고 나오지만 각각의 View들을 클릭하면 X Position의 모호함이 빨간색으로 나타나고 있고 실제로 앱을 구동하면 위와 같이 이상하게 나온다. 주어진 정보 만으로는 StackView의 위치와 크기는 정할 수 있어도 안의 각각의 View들의 크기와 위치를 계산할 수 없기 때문이다. Stack View Distribution 위와 같이 X, Y 위치 Constraint만 있는 UIStackView에 현재 길이보다 더 긴 Width Constraint를 넣어주면 어떻게 될까? 이를 위한 옵션이 5가지가 있다. 1. Fill 위와 같이 늘어날 수 있는 View를 늘린다. 2. Fill Equally 원래 크기와 상관 없이 무조건 모든 뷰에 같은 크기를 분배한다. 3. Fill Proportionally 원래 크기에 비례하여 남는 공간을 분배한다. 예를 들어 원래 크기가 1:2:3 이고 남는 공간이 60일 경우 각각의 View에게 10, 20, 30의 공간을 부여하는 것이다. 4. Equal Spacing 남는 공간을 균일하게 나눠서 View 사이에 Space를 둔다. 5. Equal Centering 각각의 뷰들의 Center 사이의 길이를 모두 같게 한다. 4. Intrinsic Content Size 모든 뷰들은 고유의 Intrinsic Content Size 가 있습니다. UILabel과 같이 해당 View의 속성만을 가지고 크기를 예측할 수 있는 경우 위와 같이 그냥 UIView는 width와 height가 결정되지 않아 빨간색으로 오류가 뜨지만 내용과 폰트 크기 만으로 Size를 예측할 수 있는 UILabel의 경우 Intrinsic Content Size가 결정되어서 오토레이아웃의 에러가 뜨지 않습니다. 12345class CustomView: UIView { override var intrinsicContentSize: CGSize { return CGSize(width: 100, height: 100) }} Intrinsic Content Size는 UIView.intrinsicContentSize에 접근하여 알아낼 수 있습니다. 또한 위와 같이 CustomView를 만들 때 intrinsicContentSize를 override 할 수도 있습니다. 만약에 intrinsicContentSize가 변했을 경우 invalidateIntrinsicContentSize()를 호출해줘야 합니다. 5. Content Hugging Priority Size Insepector의 Content Hugging Priority 입니다. 더 높은 Priority을 준다는 의미는 이 View가 intrinsic size 보다 커지지 않는다는 것을 의미합니다. labe1의 Content Hugging Priority는 251labe2의 Content Hugging Priority는 251일 때 입니다. 빨간색이 되어 있는 것을 볼 수 있습니다. labe1의 Content Hugging Priority는 252로 올린 결과 입니다. 6. Content Compression Resistance Priority Size Insepector의 Content Hugging Priority 입니다. 더 높은 Priority을 준다는 의미는 이 View가 intrinsic size 보다 작아지 않는다는 것을 의미합니다. UILabel에 horizontal 위치, vertical 위치, width 이 3개의 constraint를 주고 내용을 width보다 길게 했을 경우에는 당연히 내용이 잘려서 끝에 …이 붙습니다. 하지만 width의 priority를 1로 만들어 horizontal Content Compression Resistance Priority 보다 작게 만들어줬을 경우에는 내용이 모두 보이는 것을 알 수 있습니다. 참고https://www.raywenderlich.com/174078/auto-layout-visual-format-language-tutorial-2https://www.letmecompile.com/advanced-auto-layout/http://rhammer.tistory.com/210","link":"/iOS/Auto-Layout/"},{"title":"Facebook으로 로그인하기","text":"Facebook으로 로그인하기 1. 앱 기본 설정 페이스북 개발자 사이트에 접속해서 새 앱을 추가합니다. 자신의 앱 이름을 적고 앱 ID를 만듭니다. Facebook으로 로그인을 누릅니다. `설정`을 누릅니다. iOS를 누릅니다. iOS SDK 다운로드를 누릅니다. 다운로드 받은 뒤 압축을 풀면 위와 같은 파일이 들어있습니다. Bolts.framework, FBSDKCoreKit.framework, FBSDKLoginKit.framework 을 드래그 앤 드롭해서 Frameworks 폴더에 넣어줍니다. 만약에 이 폴더가 없으면 만들어줍니다. 이 창이 뜰텐데 꼭 Copy items if needed 를 체크해줍니다. 자기 앱의 번들ID를 적고 Save를 누른 뒤 넘어갑니다. 저 버튼을 클릭해서 활성화 해주고 Save를 누른 뒤 넘어갑니다. 라고 합니다. 밑에 사진으로 쉽게 설명 드리겠습니다. 이렇게 해서 `Info.plist` 를 코드로 엽니다. `` 태그 안에 제일 밑에 사진 같이 붙여 넣습니다. objective-c 코드로 되어 있네요. swift 코드는 밑에 써두겠습니다. AppDelegate.swift 에 아래 코드를 써주시면 됩니다. 123456789101112131415161718192021222324// AppDelegate.swiftimport FBSDKCoreKitfunc application(_ application: UIApplication, didFinishLaunchingWithOptions launchOptions: [UIApplicationLaunchOptionsKey : Any]? = nil) -&gt; Bool { FBSDKApplicationDelegate.sharedInstance().application(application, didFinishLaunchingWithOptions: launchOptions) // Add any custom logic here. return true}func application(_ application: UIApplication, open url: URL, options: [UIApplicationOpenURLOptionsKey: Any] = [:]) -&gt; Bool { let handled: Bool = FBSDKApplicationDelegate .sharedInstance() .application(application, open: url, sourceApplication: options[.sourceApplication] as? String, annotation: options[.annotation]) // Add any custom logic here. return handled} 위의 두 함수중 밑의 함수는 iOS 10 이상에서만 사용 할 수 있습니다. 따라서 그 밑 버전에서 사용하려면 아래의 코드를 사용해야 합니다. 1234567891011121314func application(_ application: UIApplication, open url: URL, sourceApplication: String?, annotation: Any) -&gt; Bool { let handled: Bool = FBSDKApplicationDelegate .sharedInstance() .application(application, open: url, sourceApplication: sourceApplication, annotation: annotation) // Add any custom logic here. return handled} 여기까지 앱의 기본 설정을 마쳤습니다.위의 7, 8, 9, 10번 단계는 밑에서 설명 하므로 넘어가셔도 됩니다. 2. Facebook 권한 요청Facebook 아주 기본적인 로그인(userID)을 제외하고 다른 기능을 사용 하려면 로그인 할 때 따로 권한 요청을 해야 합니다. 사용자의 프로필(프로필 사진 등)과 이메일을 얻으려고 하면 따로 권한 요청을 해야 합니다. 사용 가능한 권한은 다음과 같습니다. 로그인 할 때 권한 요청 하는 방법은 밑에서 다루도록 하겠습니다.자세한 사항은 여기 를 참고해 주세요. 3. Facebook SDK 버튼으로 로그인 하기Facebook SDK에서 제공하는 기본 버튼으로 로그인 하는 방법을 살펴보겠습니다.커스텀 버튼으로 로그인 하길 원하시는 분은 건너 뛰셔도 됩니다. 1234567891011121314import FBSDKCoreKitimport FBSDKLoginKitclass UIViewController { func viewDidLoad() { super.viewDidLoad() let loginButton = FBSDKLoginButton() loginButton.center = view.center loginButton.delegate = self loginButton.readPermissions = [\"public_profile\"] view.addSubview(loginButton) }} 위와 같이 코드로 버튼을 만들어 주셔도 되고 storyboard로 하셔도 됩니다.권한 요청 리스트는 FBSDKLoginButton의 readPermissions에 String Array로 넣어 주시면 됩니다.FBSDKLoginButton의 delegate는 FBSDKLoginButtonDelegate입니다. 자세한 코드는 밑에 있습니다. 12345678910111213141516171819202122extension UIViewController: FBSDKLoginButtonDelegate { func loginButton(_ loginButton: FBSDKLoginButton!, didCompleteWith result: FBSDKLoginManagerLoginResult!, error: Error?) { if let error = error { print(\"error : \\(error)\") return } if result.isCancelled { print(\"cancelled\") } else { print(\"token \\(result.token.userID!)\") } } func loginButtonDidLogOut(_ sdkButton: FBSDKLoginButton!) { print(\"loginButtonDidLogOut\") } func loginButtonWillLogin(_ sdkButton: FBSDKLoginButton!) { print(\"loginButtonWillLogin\") }} loginButton 함수는 로그인 프로세스가 끝나면 호출 되는 함수입니다.loginButtonDidLogOut 함수는 로그아웃이 되면 호출 되는 함수입니다.loginButtonWillLogin 함수는 로그인 버튼이 클릭될 때 호출 되는 함수입니다. 자세한 정보는 FBSDKLoginButtonDelegate 와 FBSDKLoginManagerLoginResult 를 확인해 주세요 앱을 실행 하면 위와 같은 버튼이 뜹니다. 이 버튼을 클릭하면 `loginButtonWillLogin` 함수가 호출 됩니다. 버튼을 클릭하면 이런 AlertDialog가 뜹니다. 그리고 로그인 화면으로 연결 됩니다. 로그인하면 이 화면이 뜹니다. 그리고 나면 다시 앱으로 돌아와서 로그인 버튼이 로그아웃 버튼으로 바뀌어 있습니다. 이 버튼을 클릭하면 로그아웃이 되고 `loginButtonDidLogOut` 함수가 호출 됩니다. 4. Custom 버튼으로 로그인 하기12345678910111213let fbLoginManager = FBSDKLoginManager()fbLoginManager.logIn(withReadPermissions: [\"public_profile\"], from: self) { (result, error) -&gt; Void in if let error = error { print(\"error : \\(error)\") return } if result.isCancelled { print(\"cancelled\") } else { print(\"token \\(result.token.userID!)\") }} 커스텀 버튼을 만들고 클릭 되면 위의 코드를 실행시키면 됩니다.권한 요청 리스트는 withReadPermissions에 String Array로 넣어 주시면 됩니다.로그아웃은 단순하게 FBSDKLoginManager의 logOut() 함수를 실행 시키면 됩니다. 1typealias FBSDKLoginManagerRequestTokenHandler = (_ result: FBSDKLoginManagerLoginResult, _ error: Error?) -&gt; Void callback함수인 FBSDKLoginManagerRequestTokenHandler은 위와 같이 정의되어 있습니다. 자세한 정보는 FBSDKLoginManager 와 FBSDKLoginManagerLoginResult 를 확인해 주세요. 5. 로그인 여부 확인하기12345678import FBSDKLoginKitif let token = FBSDKAccessToken.current() { print(\"token \\(token.userID!)\") // 로그인 되어있음} else { // 로그인 안 되어있음} 위 코드를 사용하면 로그인 여부를 확인 할 수 있습니다.","link":"/iOS/Facebook-Login/"},{"title":"Awesome Github Repository","text":"쓸만한 Github Repository 모음 Web Development Tools fullPage.js - 한 화면에서 스크롤 바만 이용해서 화면 전환을 하게 해주는 도구 (데모) Tabler - Admin Page를 만들 수 있게 해주는 도구 (데모) Typed.js - 타이핑 하는 애니메이션을 만들 수 있게 하는 도구 (데모) Airframe React - Dashboard / Admin / Analytics 템플릿 (데모) WebTorrent - 웹 브라우저와 Node에서 사용할 수 있는 Torrent 라이브러리 Swiper - 스와이핑 라이브러리의 끝판왕 (데모) SweetAlert2 - 팝업 창 라이브러리 (데모) Gitfolio - Github 사용자를 위한 개인 홈페이지/블로그 생성기 (데모) DropzoneJS - 드래그 앤 드롭 라이브러리 react-admin - 어드민 페이지 생성 도구 (데모) React-Select - Dropdown Select 라이브러리 (데모) selectize.js - Dropdown Select 라이브러리 (데모) Leaflet - OpenStreetMap 기반 지도 라이브러리 (데모) Sortable - 드래그 앤 드롭으로 순서를 바꿀 수 있는 리스트 라이브러리 (데모) Dplayer - Web Video Player (데모) Aplayer - Web Music Player (데모) Mapbox GL JS - OpenStreetMap 기반 지도 라이브러리 (데모) react-dates - 날짜 선택 라이브러리 (데모) CodeceptJS - End-to-End 프론트엔드 테스팅 라이브러리 Matter.js - 2D 물리엔진 (데모) Villain - 만화/소설 리더 라이브러리 vue-interactive-paycard - 신용카드 정보 입력 폼 라이브러리 (데모) react-interactive-paycard - 신용카드 정보 입력 폼 라이브러리 Quill - 텍스트 에디터 (데모) Slate - 텍스트 에디터 (데모) Editor.js - 텍스트 에디터 is-website-vulnerable - 웹사이트의 취약점을 찾아주는 라이브러리 Magnific Popup Repository - 이미지 확대 팝업 라이브러리 (데모) React Sortable HOC - React Sortable HOC (데모) GSAP (GreenSock Animation Platform) - 애니메이션 라이브러리 Lite YouTube Embed - 더 가벼운 Youtube Embed 태그 umi-request - axios와 같은 네트워크 요청 라이브러리 Text Mask - 입력 마스크 라이브러리 (데모) RxDB - Pub/Sub이 가능한 NoSQL-database react-use - 다양한 Custom React Hook 모음 Monaco Editor - 코드 에디터 (데모) JW Player - 동영상 플레이어 (데모) Cleave.js - 입력 마스크 라이브러리 (데모) UI Components Elastic UI - Elastic Stack에서 사용하는 UI Components chakra Semantic UI Fomantic UI - Semantic UI의 커뮤니티 버전. 업데이트가 활발함 UIkit Awesome UIkit React Rainbow WixStyleReact - Wix 스타일의 React Component 모음 Grommet Reach UI Material Components - Material Design Web Components React Suite Rebass Boilerplates &amp; Samples React Boilerplate POS - Sample Application DDD Reactive Microservices with CQRS(Command Query Responsibility Segregation) &amp; Event Sourcing Suspense Demo for Library Authors - ‘Suspense for Data Fetching’과 ‘Concurrent UI Patterns’ 예제 Relay Examples - Relay 예제 Awesome Seires Awesome Selfhosted - 본인의 머신에서 구동할 수 있는 유용한 패키지들 모음 Awesome Mac - 맥에서 설치할 수 있는 프로그램 모음 Awesome React - React 도구/라이브러리/강의 등등 모음 Awesome Node.js - Node.js 패키지 및 리소스 모음 Awesome VSCode - VSCode 플로그인 모음 Awesome Design Tools - 디자인 도구 모음 Awesome Piracy - 저작권을 무시하는 링크/데이터/프로그램 모음 Public APIs - 무료 공공 API 모음 Study Tech Interview Handbook - 기술면접을 대비한 질문 답변 리스트 What the f*ck JavaScript? - Javascript에 재밌고 이해하기 힘든 예제 모음 주니어 개발자 채용정보 - 한국 주니어 개발자를 위한 취업 정보 모음 33 Javascript Concepts - Javascript 개발자가 알아야하는 Javascript 컨셉 모음 Front-End Checklist - 프론트엔드 개발할 때 체크해야 하는 사항 모음 AWS Serverless Workshop - AWS를 이용한 Serverless 아키텍처 예제 모음 30 Seconds of Interviews - 30초 만에 볼 수 있는 기술면접 대비 질문/답변 모음 Node.js Best Practices - Node.js 좋은 예제 모음 clean-code-javascript - 클린코드를 만들기 위한 예제 모음 (한국어판) React Developer Roadmap - React 개발자의 로드맵 Didact - Step-by-step 으로 나만의 리액트를 만들 수 있음 취업 준비를 위해 공부한 내용을 정리하는 레포 Technical Interview Guidelines for Beginners 신입 개발자 전공 지식 &amp; 기술 면접 백과사전 Visulization ApexCharts.js - Interactive SVG Charts (데모) nivo - (데모) Chart.js - canvas 태그를 이용한 시각화 도구 (데모) roughViz.js - 스케치 느낌이 나는 차트 라이브러리 react-vis - (데모) G2Plot - (데모) Cube.js - 차트 생성 플랫폼 (백엔드/프론트엔드) (데모) mermaid - 다이어그램/차트/그래프/흐름 생성기 (데모) plotly.js - (데모) vis-network - 네트워크 생성기 (데모) React Financial Charts - 금융 주식 차트 (데모) Programs &amp; Websites &amp; Self-hosted Hyper - Electron 베이스 터미널 프로그램 nuclear - 공공 무료 소스를 이용한 음악 플레이어 eDEX-UI - sci-fi 느낌이 나는 터미널 프로그램 Motrix - 다운로드 매니저 LosslessCut - 손실 없이 비디오/오디오 자르기 Mark Text - 마크다운 에디터 Boostnote - 마크다운 에디터 Another Redis DeskTop Manager - Redis 데스크톱 매니저 DrawIO - 온라인 그림 도구 (사이트) STREAMA - 설치형 미디어 스트리밍 서버 (데모) Bitwarden - 비밀정보 관리 도구 PreMID - 온라인 프로그램 스토어 (사이트) Terminus - 터미널 프로그램 Util Libraries Day.js - Moment.js의 대체재로 2KB의 작은 시간/날짜 라이브러리 Yup - Javascript Object 스키마 검증 라이브러리 Nano ID - 작고, 안전하고, URL 친화적인 Unique ID 생성기 (데모) faker.js - 더미 데이터 생성기 (데모) Etc WebGL Fluid Simulation - WebGL을 이용하여 유체를 시뮬레이션한 예제 (데모) Github Trending Archive JSON server react-native-snap-carousel Emoji Screen - 이모지를 이용해서 표현한 영화, TV쇼, 뮤지컬 모음 (데모) Ghost - 블로깅 플랫폼 (Showcase) Meteor - Javascript 기반 서버/웹 개발 플랫폼 (설명) Svelte - 웹 개발 프레임워크 KeystoneJS - Node.js 기반 CMS Create Social Network - SNS 생성기 carbon - 코드 스크린샷 생성기 (데모) tsdx - Typescript 패키기 개발 도우미 strapi - 커스텀 API를 만들 수 있는 Node.js 기반 CMS (데모) VvvebJs - 드래그 앤 드롭 사이트 생성기 (데모) GrapesJS - 드래그 앤 드롭 사이트 생성기 (데모) TypeDoc - Typescript를 이용한 문서 생성기 (데모) Fantasy Map Generator - 판타지 지도 생성기 (데모) gif.js - gif 생성기 (데모) node-red - 이벤트 기반 어플리케이션을 위한 저레벨 프로그래밍 툴 (스크래치 같은거) Mostly adequate guide to FP (Book) - 함수형 프로그래밍 책 Fingerprint.js - 사용자 브라우저 정보를 이용하여 쿠키 없이 사용자 식별 (데모) Relay - React 애플리케이션을 위한 데이터 관리 프레임워크 React Query - 비동기 데이터를 얻고, 캐싱하고, 업데이트 하기 위한 React Hook Git History - 아무 Repository의 파일의 history를 빠르게 볼 수 있음 (데모) Firefox Send - 서버 설치형. 링크로 파일 공유할 수 있는 기능 (데모) fastify - express같은 web framework Zero - terminal output으로 3D 렌더링을 할 수 있는 라이브러리 Leaa - monorepo CMS built with Nest.js, Next.js, GraphQL, and Ant Design (어드민 페이지 데모)) (사용자 페이지 데모) Blocks - 드래그 앤 드롭 사이트 생성기 (데모) CSS pseudo element를 이용한 태양계 6 GitHub Repos For Instant Knowledge Boost","link":"/etc/Awesome-Github-Repository/"}],"tags":[{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"node","slug":"node","link":"/tags/node/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"eslint","slug":"eslint","link":"/tags/eslint/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"android","slug":"android","link":"/tags/android/"},{"name":"kotlin","slug":"kotlin","link":"/tags/kotlin/"},{"name":"firebase","slug":"firebase","link":"/tags/firebase/"},{"name":"fcm","slug":"fcm","link":"/tags/fcm/"},{"name":"cloud9","slug":"cloud9","link":"/tags/cloud9/"},{"name":"ec2","slug":"ec2","link":"/tags/ec2/"},{"name":"proxy","slug":"proxy","link":"/tags/proxy/"},{"name":"aws","slug":"aws","link":"/tags/aws/"},{"name":"ecs","slug":"ecs","link":"/tags/ecs/"},{"name":"elk","slug":"elk","link":"/tags/elk/"},{"name":"sse","slug":"sse","link":"/tags/sse/"},{"name":"chrome","slug":"chrome","link":"/tags/chrome/"},{"name":"tip","slug":"tip","link":"/tags/tip/"},{"name":"slack","slug":"slack","link":"/tags/slack/"},{"name":"github","slug":"github","link":"/tags/github/"},{"name":"swift","slug":"swift","link":"/tags/swift/"},{"name":"cocoapod","slug":"cocoapod","link":"/tags/cocoapod/"},{"name":"ios","slug":"ios","link":"/tags/ios/"},{"name":"view","slug":"view","link":"/tags/view/"},{"name":"uitableview","slug":"uitableview","link":"/tags/uitableview/"},{"name":"naver","slug":"naver","link":"/tags/naver/"},{"name":"clova-speech-synthesis","slug":"clova-speech-synthesis","link":"/tags/clova-speech-synthesis/"},{"name":"https","slug":"https","link":"/tags/https/"},{"name":"letsencrypt","slug":"letsencrypt","link":"/tags/letsencrypt/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"elasticsearch","slug":"elasticsearch","link":"/tags/elasticsearch/"},{"name":"audio","slug":"audio","link":"/tags/audio/"},{"name":"map","slug":"map","link":"/tags/map/"},{"name":"lambda","slug":"lambda","link":"/tags/lambda/"},{"name":"apex","slug":"apex","link":"/tags/apex/"},{"name":"facebook","slug":"facebook","link":"/tags/facebook/"}],"categories":[{"name":"server","slug":"server","link":"/categories/server/"},{"name":"node","slug":"node","link":"/categories/node/"},{"name":"android","slug":"android","link":"/categories/android/"},{"name":"etc","slug":"etc","link":"/categories/etc/"},{"name":"ios","slug":"ios","link":"/categories/ios/"},{"name":"swift","slug":"swift","link":"/categories/swift/"}]}